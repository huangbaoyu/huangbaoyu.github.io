
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>南峰子的技术博客</title>
  <meta name="author" content="南峰子">
      
  <meta name="baidu-site-verification" content="HoscFhWICI" />

  
  <meta name="description" content="本文由Colin Eberhardt发表于raywenderlich，原文可查看MVVM Tutorial with ReactiveCocoa: Part &frac12; 你可能已经在Twitter上听过这个这个笑话了： “iOS Architecture, where MVC stands &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://southpeak.github.io/posts/8">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="南峰子的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <!-- googleapis is fucked by gfw -->
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">南峰子的技术博客</a></h1>
  
    <h2>攀登，一步一个脚印，方能知其乐</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:southpeak.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/categories/ios">iOS开发</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/08/mvvmzhi-nan-yi-:flickrsou-suo-shi-li/">MVVM指南一：Flickr搜索实例</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-08T18:54:42+08:00" pubdate data-updated="true">Aug 8<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/08/08/mvvmzhi-nan-yi-:flickrsou-suo-shi-li/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文由Colin Eberhardt发表于raywenderlich，原文可查看<a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1">MVVM Tutorial with ReactiveCocoa: Part &frac12;</a></p>

<p>你可能已经在Twitter上听过这个这个笑话了：</p>

<p>“iOS Architecture, where MVC stands for Massive View Controller”</p>

<p>当然这在iOS开发圈内，这是个轻松的笑话，但我敢确定你大实践中遇到过这个问题：即视图控制器太大且难以管理。</p>

<p>这篇文章将介绍另一种构建应用程序的模式&mdash;MVVM(Model-View-ViewModel)。通过结合ReactiveCocoa便利性，这个模式提供了一个很好的代替MVC的方案，它保证了让视图控制器的轻量性。</p>

<p>在本文我，我们将通过构建一个简单的Flickr查询程序来一步步了解MVVM，这个程序的效果图如下所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp.png" alt="image" /></p>

<p>在开始写代码之前，我们先来了解一些基本的原理。</p>

<p>原文简要介绍了一下ReactiveCocoa，在此不在翻译，可以查看以下文章：</p>

<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">ReactiveCocoa指南一：信号</a></p>

<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/">ReactiveCocoa指南二：Twitter搜索实例</a></p>

<h2>MVVM模式介绍</h2>

<p>正如其名称一下，MVVM是一个UI设计模式。它是MV*模式集合中的一员。MV*模式还包含MVC(Model View Controller)、MVP(Model View Presenter)等。这些模式的目的在于将UI逻辑与业务逻辑分离，以让程序更容易开发和测试。为了更好的理解MVVM模式，我们可以看看其来源。</p>

<p>MVC是最初的UI设计模式，最早出现在Smalltalk语言中。下图展示了MVC模式的主要组成：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/MVCPattern-2.png" alt="image" /></p>

<p>这个模式将UI分成Model(表示程序状态)、View(由UI控件组成)、Controller(处理用户交互与更新model)。MVC模式的最大问题是其令人相当困惑。它的概念看起来很好，但当我们实现MVC时，就会产生上图这种Model-View-Controller之间的环状关系。这种相互关系将会导致可怕的混乱。</p>

<p>最近Martin Fowler介绍了MVC模式的一个变种，这种模式命名为MVVM，并被微软广泛采用并推广。</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMPattern.png" alt="image" /></p>

<p>这个模式的核心是ViewModel，它是一种特殊的model类型，用于表示程序的UI状态。它包含描述每个UI控件的状态的属性。例如，文本输入域的当前文本，或者一个特定按钮是否可用。它同样暴露了视图可以执行哪些行为，如按钮点击或手势。</p>

<p>我们可以将ViewModel看作是视图的模型(model-of-the-view)。MVVM模式中的三部分比MVC更加简洁，下面是一些严格的限制</p>

<ol>
<li>View引用了ViewModel，但反过来不行。</li>
<li>ViewModel引用了Model，但反过来不行。</li>
</ol>


<p>如果我们破坏了这些规则，便无法正确地使用MVVM。</p>

<p>这个模式有以下一些立竿见影的优势：</p>

<ol>
<li>轻量的视图：所有的UI逻辑都在ViewModel中。</li>
<li>便于测试：我们可以在没有视图的情况下运行整个程序，这样大大地增加了它的可测试性。</li>
</ol>


<p>现在你可能注意到一个问题。如果View引用了ViewModel，但ViewModel没有引用View，那ViewModel如何更新视图呢？哈哈，这就得靠MVVM模式的私密武器了。</p>

<h2>MVVM和数据绑定</h2>

<p>MVVM模式依赖于数据绑定，它是一个框架级别的特性，用于自动连接对象属性和UI控件。例如，在微软的WPF框架中，下面的标签将一个TextField的Text属性绑定到ViewModel的Username属性中。</p>

<pre><code>&lt;TextField Text=”{DataBinding Path=Username, Mode=TwoWay}”/&gt;
</code></pre>

<p>WPF框架将这两个属性绑定到一起。</p>

<p>不过可惜的是，iOS没有数据绑定框架，幸运的是我们可以通过ReactiveCocoa来实现这一功能。我们从iOS开发的角度来看看MVVM模式，ViewController及其相关的UI(nib, stroyboard或纯代码的View)组成了View:</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa.png" alt="image" /></p>

<p>&hellip;&hellip;而ReactiveCocoa绑定了View和ViewModel。</p>

<p>理论讲得差不多了，我们可以开始新的历程了。</p>

<h2>启动项目结构</h2>

<p>可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchStarterProject1.zip">FlickrSearchStarterProject.zip</a>中下载启动项目。我们使用Cocoapods来管理第三方库，在对应目录下执行pod install命令生成依赖库后，我们就可以打开生成的RWTFlickrSearch.xcworkspace来运行我们的项目了，初始运行效果如下图：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/first-launch.jpg" alt="image" /></p>

<p>我们行熟悉下工程的结构：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/06/EmptyInterface.png" alt="image" /></p>

<p>Model和ViewModel分组目前是空的，我们会慢慢往里面添加东西。View分组包含以下几个类</p>

<ol>
<li>RWTFlickSearchViewController：程序的主屏幕，包含一个搜索输入域和一个GO按钮。</li>
<li>RWTRecentSearchItemTableViewCell：用于在主页中显示搜索结果的table cell</li>
<li>RWTSearchResultsViewController：搜索结果页，显示来自Flickr的tableview</li>
<li>RWTSearchResultsTableViewCell：渲染来自Flickr的单个图片的table cell。</li>
</ol>


<p>现在来写我们的第一个ViewModel吧。</p>

<h2>第一个ViewModel</h2>

<p>在ViewModel分组中添加一个继承自NSObject的新类RWTFlickrSearchViewModel。然后在该类的头文件中，添加以下两行代码：</p>

<pre><code>@property (nonatomic, strong) NSString *searchText;
@property (nonatomic, strong) NSString *title;
</code></pre>

<p>searchText属性表示文本域中显示文本，title属性表示导航条上的标题。</p>

<p>打开RWTFlickrSearchViewModel.m文件添加以下代码：</p>

<pre><code>@implementation RWTFlickrSearchViewModel

- (instancetype)init
{
    self = [super init];

    if (self)
    {
        [self initialize];
    }

    return self;
}

- (void)initialize
{
    self.searchText = @"search text";
    self.title = @"Flickr Search";
}

@end
</code></pre>

<p>这段代码简单地设置了ViewModel的初始状态。</p>

<p>接下来我们将连接ViewModel到View。记住View保存了一个ViewModel的引用。在这种情况下，添加一个给定ViewModel的初始化方法来构造View是很有必要的。打开RWTFlickrSearchViewController.h，并导入ViewModel头文件：</p>

<pre><code>#import "RWTFlickrSearchViewModel.h"
</code></pre>

<p>并添加以下初始化方法：</p>

<pre><code>@interface RWTFlickrSearchViewController : UIViewController

- (instancetype)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel;

@end
</code></pre>

<p>在RWTFlickrSearchViewController.m中，在类的扩展中添加以下私有属性：</p>

<pre><code>@property (weak, nonatomic) RWTFlickrSearchViewModel *viewModel;
</code></pre>

<p>然后添加以下方法：</p>

<pre><code>- (instancetype)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel
{
    self = [super init];

    if (self)
    {
        _viewModel = viewModel;
    }

    return self;
}
</code></pre>

<p>这就在view中存储了一个到ViewModel的引用。<em>注意这是一个弱引用，这样View引用了ViewModel，但没有拥有它。</em></p>

<p>接下来在viewDidLoad里面添加下面代码：</p>

<pre><code>[self bindViewModel];
</code></pre>

<p>该方法的实现如下：</p>

<pre><code>- (void)bindViewModel
{
    self.title = self.viewModel.title;
    self.searchTextField.text = self.viewModel.searchText;
}
</code></pre>

<p>最后我们需要创建ViewModel，并将其提供给View。在RWTAppDelegate.m中，添加以下头文件：</p>

<pre><code>#import "RWTFlickrSearchViewModel.h"
</code></pre>

<p>同时添加一个私有属性：</p>

<pre><code>@property (nonatomic, strong) RWTFlickrSearchViewModel *viewModel;
</code></pre>

<p>我们会发现这个类中已以有一个createInitialViewController方法了，我们用以下代码来更新它：</p>

<pre><code>- (UIViewController *)createInitialViewController {
    self.viewModel = [RWTFlickrSearchViewModel new];
    return [[RWTFlickrSearchViewController alloc] initWithViewModel:self.viewModel];
}
</code></pre>

<p>这个方法创建了一个ViewModel实例，然后构造并返回了View。这个视图作程序导航控制器的初始视图。</p>

<p>运行后的状态如下：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/ViewWithState-333x500.png" alt="image" /></p>

<p>这样我们就得到了第一个ViewModel。不过仍然有许多东西要学的。你可能已经发现了我们还没有使用ReactiveCocoa。到目前为止，用户在输入框上的输入操作不会影响到ViewModel。</p>

<h2>检测可用的搜索状态</h2>

<p>现在，我们来看看如何用ReactiveCocoa来绑定ViewModel和View，以将搜索输入框和按钮连接到ViewModel。</p>

<p>在RWTFlickrSearchViewController.m中，我们使用如下代码更新bindViewModel方法。</p>

<pre><code>- (void)bindViewModel
{
    self.title = self.viewModel.title;
    RAC(self.viewModel, searchText) = self.searchTextField.rac_textSignal;
}
</code></pre>

<p>在ReactiveCocoa中，使用了分类将rac_textSignal属性添加到UITextField类中。它是一个信号，在文本域每次更新时会发送一个包含当前文本的next事件。</p>

<p>RAC是一个用于做绑定操作的宏，上面的代码会使用rac_textSignal发出的next信号来更新viewModel的searchText属性。</p>

<p>搜索按钮应该只有在用户输入有效时才可点击。为了方便起见，我们以输入字符大于3时输入有效为准。在RWTFlickrSearchViewModel.m中导入以下头文件。</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>然后更新初始化方法：</p>

<pre><code>- (void)initialize
{
    self.title = @"Flickr Search";

    RACSignal *validSearchSignal =
    [[RACObserve(self, searchText)
      map:^id(NSString *text) {
        return @(text.length &gt; 3);
    }]
     distinctUntilChanged];

    [validSearchSignal subscribeNext:^(id x) {
        NSLog(@"search text is valid %@", x);
    }];
}
</code></pre>

<p>运行程序并在输入框中输入一些字符，在控制台中我们可以看到以下输出：</p>

<pre><code>2014-08-07 21:50:44.078 RWTFlickrSearch[3116:60b] search text is valid 0
2014-08-07 21:50:59.493 RWTFlickrSearch[3116:60b] search text is valid 1
2014-08-07 21:51:02.594 RWTFlickrSearch[3116:60b] search text is valid 0
</code></pre>

<p>上面的代码使用RACObserve宏来从ViewModel的searchText属性创建一个信号。map操作将文本转化为一个true或false值的流。</p>

<p>最后，distinctUntilChanges确保信号只有在状态改变时才发出值。</p>

<p>到目前为止，我们可以看到ReactiveCocoa被用于将绑定View绑定到ViewModel，确保了这两者是同步的。另进一步地，ViewModel内部的ReactiveCocoa代码用于观察自己的状态及执行其它操作。</p>

<p>这就是MVVM模式的基本处理过程。ReactiveCocoa通常用于绑定View和ViewModel，但在程序的其它层也非常有用。</p>

<h2>添加搜索命令</h2>

<p>本节将上面创建的validSearchSignal来创建绑定到View的操作。打开RWTFlickrSearchViewModel.h并添加以下头文件</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>同时添加以下属性</p>

<pre><code>@property (strong, nonatomic) RACCommand *executeSearch;
</code></pre>

<p>RACCommand是ReactiveCocoa中用于表示UI操作的一个类。它包含一个代表了UI操作的结果的信号以及标识操作当前是否被执行的一个状态。</p>

<p>在RWTFlickrSearchViewModel.m的initialize方法的最后添加以下代码：</p>

<pre><code>self.executeSearch = [[RACCommand alloc] initWithEnabled:validSearchSignal
                                             signalBlock:^RACSignal *(id input) {
                                                 return [self executeSearchSignal];
                                             }];
</code></pre>

<p>这创建了一个在validSearchSignal发送true时可用的命令。另外，需要在下面实现executeSearchSignal方法，它提供了命令所执行的操作。</p>

<pre><code>- (RACSignal *)executeSearchSignal
{
    return [[[[RACSignal empty] logAll] delay:2.0] logAll];
}
</code></pre>

<p>在这个方法中，我们执行一些业务逻辑操作，以作为命令执行的结果，并通过信号异步返回结果。</p>

<p>到目前为止，上述代码只提供了一个简单的实现：空信号会立即完成。delay操作会将其所接收到的next或complete事件延迟两秒执行。</p>

<p>最后一步是将这个命令连接到View中。打开RWTFlickrSearchViewController.m并在bindViewModel方法的结尾中添加以下代码：</p>

<pre><code>self.searchButton.rac_command = self.viewModel.executeSearch;
</code></pre>

<p>rac_command属性是UIButton的ReactiveCocoa分类中添加的属性。上面的代码确保点击按钮执行给定的命令，且按钮的可点击状态反应了命令的可用状态。</p>

<p>运行代码，输入一些字符并点击GO，得到如下结果：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/06/GoButtonEnabled-333x500.png" alt="image" /></p>

<p>可以看到，当输入有效点击按钮时，按钮会置灰2秒钟，当执行的信号完成时又可点击。我们可以看下控制台的输出，可以发现空信号会立即完成，而延迟操作会在2秒后发出事件：</p>

<pre><code>2014-08-07 22:21:25.128 RWTFlickrSearch[3161:60b] &lt;RACDynamicSignal: 0x17005ba20&gt; name: +empty completed
2014-08-07 22:21:27.329 RWTFlickrSearch[3161:60b] &lt;RACDynamicSignal: 0x17005dd30&gt; name: [+empty] -delay: 2.000000 completed
</code></pre>

<p>是不是很酷？</p>

<h2>绑定、绑定还是绑定</h2>

<p>RACCommand监听了搜索按钮状态的更新，但处理activity indicator的可见性则由我们负责。RACCommand暴露了一个executing属性，它是一个信号，发送true或false来标明命令开始和结束执行的时间。我们可以用这个来影响当前命令的状态。</p>

<p>在RWTFlickrSearchViewController.m中的bindViewModel方法结尾处添加以下代码：</p>

<pre><code>RAC([UIApplication sharedApplication], networkActivityIndicatorVisible) = self.viewModel.executeSearch.executing;
</code></pre>

<p>这将UIApplication的networkActivityIndicatorVisible属性绑定到命令的executing信号中。这确保了不管命令什么时候执行，状态栏中的网络activity indicator都会显示。</p>

<p>接下来添加以下代码：</p>

<pre><code>RAC(self.loadingIndicator, hidden) = [self.viewModel.executeSearch.executing not];
</code></pre>

<p>当命令执行时，应该隐藏加载indicator。这可以通过not操作来反转信号。</p>

<p>最后，添加以下代码：</p>

<pre><code>[self.viewModel.executeSearch.executionSignals subscribeNext:^(id x) {
    [self.searchTextField resignFirstResponder];
}];
</code></pre>

<p>这段代码确保命令执行时隐藏键盘。executionSignals属性发送由命令每次执行时生成的信号。这个属性是信号的信号(见<a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">ReactiveCocoa指南一：信号</a>)。当创建和发出一个新的命令执行信号时，隐藏键盘。</p>

<p>运行程序看看效果如何吧。</p>

<h2>Model在哪？</h2>

<p>到目前为止，我们已经有了一个清晰的View(RWTFlickrSearchViewController)和ViewModel(RWTFlickrSearchViewModel)，但是Model在哪呢？</p>

<p>答案很简单：没有！</p>

<p>当前的程序执行一个命令来响应用户点击搜索按钮的操作，但是实现不做任何值的处理。ViewModel真正需要做的是使用当前的searchText来搜索Flickr，并返回一个匹配的列表。</p>

<p>我们应该可以直接在ViewModel添加业务逻辑，但相信我，你不希望这么做。如果这是一个viewcontroller，我打赌你一定会直接这么做。</p>

<p>ViewModel暴露属性来表示UI状态，它同样暴露命令来表示UI操作(通常是方法)。ViewModel负责管理基于用户交互的UI状态的改变。然而它不负责实际执行这些交互产生的的业务逻辑，那是Model的工作。</p>

<p>接下来，我们将在程序中添加Model层。</p>

<p>在Model分组中，添加RWTFlickrSearch协议并提供以下实现</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;

@protocol RWTFlickrSearch &lt;NSObject&gt;

- (RACSignal *)flickrSearchSignal:(NSString *)searchString;

@end
</code></pre>

<p>这个协议定义了Model层的初始接口，并将搜索Flickr的责任移出ViewModel。</p>

<p>接下来在Model分组中添加RWTFlickrSearchImpl类，其继承自NSObject，并实现了RWTFlickrSearch协议，如下代码所示：</p>

<pre><code>#import "RWTFlickrSearch.h"

@interface RWTFlickrSearchImpl : NSObject &lt;RWTFlickrSearch&gt;

@end
</code></pre>

<p>打开RWTFlickrSearchImpl.m文件，提供以下实现：</p>

<p>@implementation RWTFlickrSearchImpl</p>

<pre><code>- (RACSignal *)flickrSearchSignal:(NSString *)searchString
{
    return [[[[RACSignal empty] logAll] delay:2.0] logAll];
}

@end
</code></pre>

<p>看着是不是有hkko眼熟？没错，我们在上面的ViewModel中有相同的实现。</p>

<p>接下来我们需要在ViewModel层中使用Model层。在ViewModel分组中添加RWTViewModelServices协议并如下实现：</p>

<pre><code>#import "RWTFlickrSearch.h"

@protocol RWTViewModelServices &lt;NSObject&gt;

- (id&lt;RWTFlickrSearch&gt;)getFlickrSearchService;

@end
</code></pre>

<p>这个协议定义了唯一的一个方法，以允许ViewModel获取一个引用，以指向RWTFlickrSearch协议的实现对象。</p>

<p>打开RWTFlickrSearchViewModel.h并导入头文件</p>

<pre><code>#import "RWTViewModelServices.h"
</code></pre>

<p>更新初始化方法并将RWTViewModelServices作为一个参数：</p>

<pre><code>- (instancetype)initWithServices:(id&lt;RWTViewModelServices&gt;)services;
</code></pre>

<p>在RWTFlickrSearchViewModel.m中，添加类的分类并提供一个私有属性来维护一个到RWTViewModelServices的引用：</p>

<pre><code>@interface RWTFlickrSearchViewModel ()

@property (nonatomic, weak) id&lt;RWTViewModelServices&gt; services;

@end
</code></pre>

<p>在该文件下面，添加初始化方法的实现：</p>

<pre><code>- (instancetype)initWithServices:(id&lt;RWTViewModelServices&gt;)services
{
    self = [super init];

    if (self)
    {
        _services = services;
        [self initialize];
    }

    return self;
}
</code></pre>

<p>这只是简单的存储了services的引用。</p>

<p>最后，更新executeSearchSignal方法：</p>

<pre><code>- (RACSignal *)executeSearchSignal
{
    return [[self.services getFlickrSearchService] flickrSearchSignal:self.searchText];
}
</code></pre>

<p>最后是连接Model和ViewModel。</p>

<p>在工程的根分组中，添加一个NSObject的子类RWTViewModelServicesImpl。打开RWTViewModelServicesImpl.h并实现RWTViewModelServices协议：</p>

<pre><code>#import "RWTViewModelServices.h"

@interface RWTViewModelServicesImpl : NSObject &lt;RWTViewModelServices&gt;

@end
</code></pre>

<p>打开RWTViewModelServicesImpl.m，并添加实现：</p>

<pre><code>#import "RWTFlickrSearchImpl.h"

@interface RWTViewModelServicesImpl ()

@property (strong, nonatomic) RWTFlickrSearchImpl *searchService;

@end

@implementation RWTViewModelServicesImpl

- (instancetype)init
{
    if (self = [super init])
    {
        _searchService = [RWTFlickrSearchImpl new];
    }

    return self;
}

- (id&lt;RWTFlickrSearch&gt;)getFlickrSearchService
{
    return self.searchService;
}

@end
</code></pre>

<p>这个类简单创建了一个RWTFlickrSearchImpl实例，用于Model层搜索Flickr服务，并将其提供给ViewModel的请求。</p>

<p>最后，在RWTAppDelegate.m中添加以下头文件</p>

<pre><code>#import "RWTViewModelServicesImpl.h"
</code></pre>

<p>并添加一个新的私有属性</p>

<pre><code>@property (nonatomic, strong) RWTViewModelServicesImpl *viewModelServices;
</code></pre>

<p>再更新createInitialViewController方法：</p>

<pre><code>- (UIViewController *)createInitialViewController {
    self.viewModelServices = [RWTViewModelServicesImpl new];
    self.viewModel = [[RWTFlickrSearchViewModel alloc] initWithServices:self.viewModelServices];
    return [[RWTFlickrSearchViewController alloc] initWithViewModel:self.viewModel];
}
</code></pre>

<p>运行程序，验证程序有没有按之前的方式来工作。当然，这不是最有趣的变化，不过，可以看看新代码的形状了。</p>

<p>Model层暴露了一个ViewModel层使用的&#8217;服务&#8217;。一个协议定义了这个服务的接口，提供了松散的组合。</p>

<p>我们可以使用这种方式来为单元测试提供一个类似的服务实现。程序现在有了正确的MVVM结构，让我们小结一下：</p>

<ol>
<li>Model层暴露服务并负责提供程序的业务逻辑实现。</li>
<li>ViewModel层表示程序的视图状态(view-state)。同时响应用户交互及来自Model层的事件，两者都受view-state变化的影响。</li>
<li>View层很薄，只提供ViewModel状态的显示及输出用户交互事件。</li>
</ol>


<h2>搜索Flickr</h2>

<p>我们继续来完成Flickr的搜索实现，事情变得越来越有趣了。</p>

<p>首先我们创建表示搜索结果的模型对象。在Model分组中，添加RWTFlickrPhoto类，并为其添加三个属性。</p>

<pre><code>@interface RWTFlickrPhoto : NSObject

@property (nonatomic, strong) NSString *title;
@property (nonatomic, strong) NSURL *url;
@property (nonatomic, strong) NSString *identifier;

@end
</code></pre>

<p>这个模型对象表示由Flickr搜索API返回一个图片。</p>

<p>打开RWTFlickrPhoto.m，并添加以下描述方法的实现：</p>

<pre><code>- (NSString *)description
{
    return self.title;
}
</code></pre>

<p>接下来，新建一个新的模型对象类RWTFlickrSearchResults，并添加以下属性：</p>

<pre><code>@interface RWTFlickrSearchResults : NSObject

@property (strong, nonatomic) NSString *searchString;
@property (strong, nonatomic) NSArray *photos;
@property (nonatomic) NSInteger totalResults;

@end
</code></pre>

<p>这个类表示由Flickr搜索返回的照片集合。</p>

<p>是时候实现搜索Flickr了。打开RWTFlickrSearchImpl.m并导入以下头文件：</p>

<pre><code>#import "RWTFlickrSearchResults.h"
#import "RWTFlickrPhoto.h"
#import &lt;objectiveflickr/ObjectiveFlickr.h&gt;
#import &lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;
</code></pre>

<p>然后添加以下类扩展：</p>

<pre><code>@interface RWTFlickrSearchImpl () &lt;OFFlickrAPIRequestDelegate&gt;

@property (strong, nonatomic) NSMutableSet *requests;
@property (strong, nonatomic) OFFlickrAPIContext *flickrContext;

@end
</code></pre>

<p>这个类实现了OFFlickrAPIRequestDelegate协议，并添加了两个私有属性。我们会很快看到如何使用这些值。</p>

<p>继续添加代码：</p>

<pre><code>- (instancetype)init
{
    self = [super init];

    if (self)
    {
        NSString *OFSampleAppAPIKey = @"YOUR_API_KEY_GOES_HERE";
        NSString *OFSampleAppAPISharedSecret = @"YOUR_SECRET_GOES_HERE";

        _flickrContext = [[OFFlickrAPIContext alloc] initWithAPIKey:OFSampleAppAPIKey sharedSecret:OFSampleAppAPISharedSecret];

        _requests = [NSMutableSet new];
    }

    return self;
}
</code></pre>

<p>这段代码创建了一个Flickr的上下文，用于存储ObjectiveFlickr请求的数据。</p>

<p>当前Model层服务类提供的API有一个单独的方法，用于查找基于文本搜索字符的图片。不过我们一会会添加更多的方法。</p>

<p>在RWTFlickrSearchImpl.m中添加以下方法：</p>

<pre><code>- (RACSignal *)signalFromAPIMethod:(NSString *)method arguments:(NSDictionary *)args transform:(id (^)(NSDictionary *response))block
{
    // 1. 创建请求信号
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        // 2. 创建一个Flick请求对象
        OFFlickrAPIRequest *flickrRequest = [[OFFlickrAPIRequest alloc] initWithAPIContext:self.flickrContext];
        flickrRequest.delegate = self;
        [self.requests addObject:flickrRequest];

        // 3. 从代理方法中创建一个信号
        RACSignal *successSignal = [self rac_signalForSelector:@selector(flickrAPIRequest:didCompleteWithResponse:)
                                                  fromProtocol:@protocol(OFFlickrAPIRequestDelegate)];

        // 4. 处理响应
        [[[successSignal
         map:^id(RACTuple *tuple) {
             return tuple.second;
         }]
         map:block]
         subscribeNext:^(id x) {
             [subscriber sendNext:x];
             [subscriber sendCompleted];
         }];

        // 5. 开始请求
        [flickrRequest callAPIMethodWithGET:method arguments:args];

        // 6. 完成后，移除请求的引用
        return [RACDisposable disposableWithBlock:^{
            [self.requests removeObject:flickrRequest];
        }];
    }];
}
</code></pre>

<p>这个方法需要传入请求方法及请求参数，然后使用block参数来转换响应对象。我们重点看一下第4步：</p>

<pre><code>[[[successSignal
  // 1. 从flickrAPIRequest:didCompleteWithResponse:代理方法中提取第二个参数
  map:^id(RACTuple *tuple) {
    return tuple.second;
  }]
  // 2. 转换结果
  map:block]
  subscribeNext:^(id x) {
    // 3. 将结果发送给订阅者
    [subscriber sendNext:x];
    [subscriber sendCompleted];
  }];
</code></pre>

<p>rac_signalForSelector:fromProtocol: 方法创建了successSignal，同样也在代理方法的调用中创建了信号。</p>

<p>代理方法每次调用时，发出的next事件会附带包含方法参数的RACTuple。</p>

<p>实现Flickr搜索的最后一步如下：</p>

<pre><code>- (RACSignal *)flickrSearchSignal:(NSString *)searchString {
  return [self signalFromAPIMethod:@"flickr.photos.search"
                         arguments:@{@"text": searchString,
                                     @"sort": @"interestingness-desc"}
                         transform:^id(NSDictionary *response) {

    RWTFlickrSearchResults *results = [RWTFlickrSearchResults new];
    results.searchString = searchString;
    results.totalResults = [[response valueForKeyPath:@"photos.total"] integerValue];

    NSArray *photos = [response valueForKeyPath:@"photos.photo"];
    results.photos = [photos linq_select:^id(NSDictionary *jsonPhoto) {
      RWTFlickrPhoto *photo = [RWTFlickrPhoto new];
      photo.title = [jsonPhoto objectForKey:@"title"];
      photo.identifier = [jsonPhoto objectForKey:@"id"];
      photo.url = [self.flickrContext photoSourceURLFromDictionary:jsonPhoto
                                                              size:OFFlickrSmallSize];
      return photo;
    }];

    return results;
  }];
}
</code></pre>

<p>上面的方法使用signalFromAPIMethod:arguments:transform:方法。flickr.photos.search方法提供的字典来搜索照片。</p>

<p>传递给transform参数的block简单地将NSDictionary响应转化为一个等价的模型对象，让它在ViewModel中更容易使用。</p>

<p>最后一步是打开RWTFlickrSearchViewModel.m方法，然后更新搜索信号来记录日志：</p>

<pre><code>- (RACSignal *)executeSearchSignal {
  return [[[self.services getFlickrSearchService]
           flickrSearchSignal:self.searchText]
           logAll];
}
</code></pre>

<p>编译，运行并输入一些字符后可在控制台看到以下日志：</p>

<pre><code>2014-06-03 [...] &lt;RACDynamicSignal: 0x8c368a0&gt; name: +createSignal: next: searchString=wibble, totalresults=1973, photos=(
    "Wibble, wobble, wibble, wobble",
    "unoa-army",
    "Day 277: Cheers to the freakin' weekend!",
    [...]
    "Angry sky",
    Nemesis
)
</code></pre>

<p>这样我们MVVM指南的第一部分就差不多结束了，但在结束之前，让我们先看看内存问题吧。</p>

<h2>内存管理</h2>

<p>正如在<a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/">ReactiveCocoa指南二：Twitter搜索实例</a>中所讲的一样，我们在block中使用了self，这可能会导致循环引用的问题。而为了避免此问题，我们需要使用@weakify和@strongify宏来打破这种循环引用。</p>

<p>不过看看signalFromAPIMethod:arguments:transform:方法，你可能会迷惑为什么没有使用这两个宏来引用self？这是因为block是作为createSignal:方法的一个参数，它不会在self和block之间建立一个强引用关系。迷茫了吧？不相信的话只需要测试一样这段代码有没有内存泄露就行。当然这时候就得用Instruments了，自己去看吧。哈哈。</p>

<h2>何去何从？</h2>

<p>例子工程的完整代码可以在<a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip">这里</a>下载。在下一部分中，我们将看看如何从ViewModel中初始化一个视图控制器并实现更多的Flickr请求操作。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/">ReactiveCocoa指南二：Twitter搜索实例</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-02T23:20:48+08:00" pubdate data-updated="true">Aug 2<sup>nd</sup>, 2014</time>
        
        
           | <a href="/blog/2014/08/02/reactivecocoazhi-nan-er-:twittersou-suo-shi-li/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文由Colin Eberhardt发表于raywenderlich，<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>

<p><a href="http://southpeak.github.io/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">第一部分</a>我们学习了ReactiveCocoa处理信号的基本流程，如何发送流事件，以及分割及组合信号。在这一部分中，我们将继续学习ReactiveCocoa更多的特性，包括：</p>

<ol>
<li>error和completed事件类型</li>
<li>节流(Throttling)</li>
<li>线程</li>
<li>扩展</li>
</ol>


<h2>Twitter Instant</h2>

<p>本部分我们将要开发的是一个称为Twitter Instant的程序，这是一个Twitter搜索应用，用于裡更新搜索结果。可以在<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstant-Starter2.zip">这里</a>下载初始程序，同时我们需要通过Cocoapods来下载依赖库，这个过程与第一部分相同。完成之后，运行程序，将得到下面的界面：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/TwitterInstantStarter.png" alt="image" /></p>

<p>我们花点时间熟悉一下。这个程序很简单。左侧控制面板是RWSearchFormViewController，有一个搜索框。右侧是RWSearchResultsViewController。如果我们打开RWSearchFormViewController.m，我们可以看到viewDidLoad方法中指定了resultsViewController属性，这个程序的主要逻辑是在RWSearchFormViewController中，这个属性将搜索结果提供给RWSearchResultsViewController。</p>

<h2>验证搜索框</h2>

<p>首先我们来校验输入框的字符长度是否大于2。我们在RWSearchFormViewController.m的viewDidLoad方法下面添加以下代码：</p>

<pre><code>- (BOOL)isValidSearchText:(NSString *)text
{
    return text.length &gt; 2;
}
</code></pre>

<p>接下来，我们在RWSearchFormViewController.m中导入ReactiveCocoa</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>同时在viewDidLoad方法最后加上以下代码：</p>

<pre><code>[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    self.searchText.backgroundColor = color;
}];
</code></pre>

<p>这段代码通过信号来检测输入是否有效，并设置相应的输入框背影颜色值。运行后，可以看到如下效果：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/ValidatedTextField.png" alt="image" /></p>

<p>其管道流程图如下所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextValidationPipeline.png" alt="image" /></p>

<p>rac_textSignal在每次输入时发出next事件，并包含当前输入框的文本。然后map操作将其转换为颜色值，最后subscribeNext:获取这个颜色值并用它来设置输入框的背景颜色。</p>

<p>在添加Twitter查找逻辑之前，我们先看看一些有趣的东西。</p>

<h2>格式化管道代码</h2>

<p>在调用信号的方法时，我们建议每个操作都新起一行，并排列所有的步骤。如下图所示，一个复杂的管道通过分行，看起来会更加清晰</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/PipelineFormatting.png" alt="image" /></p>

<h2>内存管理</h2>

<p>考虑下我们添加到TwitterInstant程序中的代码，想知道我们创建的管道是如何被保存的么？当然，因为它没有被指定给变量或属性，所以它没有增加引用计数，因此注定被销毁？ReactiveCocoa设计的目的之一是允许这样一种编程样式，即管道可以匿名创建。到目前为止，我们的管道都是这么处理的。为了支持这种模式，ReactiveCocoa维护了一个全局的信号集合。如果信号有一个或多个订阅者，它就是可用的。如果所有订阅者都被移除了，信号就被释放了。</p>

<p>剩下最后一个问题：如何取消对信号的订阅？在一个completed事件或error事件后，一个订阅者会自动将自己移除。手动移除可能通过<strong>RACDisposable</strong>来完成。RACSignal的所有订阅方法都返回一个RACDisposable实例，我们可以调用它的dispose方法来手动移除订阅者。如下代码所示：</p>

<pre><code>RACSignal *backgroundColorSignal =
    [self.searchText.rac_textSignal
     map:^id(NSString *text) {
         return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
     }];

RACDisposable *subscripion =
    [backgroundColorSignal subscribeNext:^(UIColor *color) {
        self.searchText.backgroundColor = color;
    }];

// 在某个位置调用
[subscripion dispose];
</code></pre>

<p>当然实际上我们不需要这样来写，只需要知道是这么回事就行。</p>

<p><em>注意：如果我们创建了一个管道，但不去订阅它，则管理永远不会执行，包括任何如doNext:块这样的附加操作。</em></p>

<h2>避免循环引用</h2>

<p>ReactiveCocoa在幕后做了许多事情，让我们不需要担心信号的内存管理问题，但有一点关于内存管理的问题需要特别注意。我们先来看看下面的代码：</p>

<pre><code>[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    self.searchText.backgroundColor = color;
}];
</code></pre>

<p>subscribeNext:块使用了self，以获取文本输入域。Block会捕获并保留闭包中的值，因此如果在self与信号之间有一个强引用，则会导致循环引用问题。这是不是问题取决于self对象的生命周期。如果self的生命周期是整个程序生存期，则没问题，好好用吧。但在大多数情况下，它确实是一个问题。</p>

<p>为了避循环引用，根据苹果的文档中推荐的捕获self的一个弱引用。如下代码所示：</p>

<pre><code>__typeof(self) __weak weakSelf = self;

[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [weakSelf isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    weakSelf.searchText.backgroundColor = color;
}];
</code></pre>

<p>在上面的代码中weakSelf是self对象的一个弱引用。现在subscribeNext:中使用了这个变量。不过ReactiveCocoa框架给我们提供了一个更好的选择。首先导入以下头文件：</p>

<pre><code>#import &lt;RACEXTScope.h&gt;
</code></pre>

<p>然后使用以下代码：</p>

<pre><code>@weakify(self)

[[self.searchText.rac_textSignal map:^id(NSString *text) {
    return [self isValidSearchText:text] ? [UIColor whiteColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    @strongify(self)
    self.searchText.backgroundColor = color;
}];
</code></pre>

<p>宏@weakify与@strongify在<a href="https://github.com/jspahrsummers/libextobjc">Extended Objective-C</a>库中引用，它们包含在ReactiveCocoa框架中。@weakify允许我们创建一些影子变量，它是都是弱引用(可以同时创建多个)，@strongify允许创建变量的强引用，这些变量是先前传递给@weakify的。</p>

<p>最后需要注意的是，当在block中使用实例变量时，block同样会捕获self的一个强引用。我们可以打开编译器警告，来提示我们这种情况。如下所求来处理</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AvoidRetainSelf.png" alt="image" /></p>

<p>OK，内存问题说得差不多了，现在我们回到正题。</p>

<h2>请求访问Twitter</h2>

<p>我们将使用Social Framework以允许TwitterInstant程序搜索Tweets，同时使用Accounts Framework来获取对Twitter的访问。</p>

<p>在添加代码前，我们需要先登录Twitter。可以在系统的设置中登录，如下图所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/TwitterCredentials.png" alt="image" /></p>

<p>我们的工程已经添加了所需要的框架，所以只需要在RWSearchFormViewController.m导入头文件。</p>

<pre><code>#import &lt;Accounts/Accounts.h&gt;
#import &lt;Social/Social.h&gt;
</code></pre>

<p>然后在下面添加枚举及常量用于标识错误：</p>

<pre><code>typedef NS_ENUM(NSInteger, RWTwitterInstantError) {
    RWTwitterInstantErrorAccessDenied,
    RWTwitterInstantErrorNoTwitterAccounts,
    RWTwitterInstantErrorInvalidResponse
};

static NSString * const RWTwitterInstantDomain = @"TwitterInstant";
</code></pre>

<p>然后我们RWSearchFormViewController()分类中添加以下代码：</p>

<pre><code>@property (strong, nonatomic) ACAccountStore *accountStore;
@property (strong, nonatomic) ACAccountType *twitterAccountType;
</code></pre>

<p>ACAccountsStore类提供了我们的设备可连接的多种社交账号，ACAccountType类表示账号的指定类型。</p>

<p>我们在viewDidLoad的结尾处添加以下代码，来创建账户存储及Twitter账户标识：</p>

<pre><code>self.accountStore = [[ACAccountStore alloc] init];
self.twitterAccountType = [self.accountStore accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];
</code></pre>

<p>当账户请求社账号时，用户可以看到一个弹出框。这是一个异步操作，所以将其包装到一个信号中是很好的选择。</p>

<p>仍然在这个文件中，添加以下代码：</p>

<pre><code>- (RACSignal *)requestAccessToTwitterSignal
{
    // 定义一个错误，如果用户拒绝访问则发送
    NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorAccessDenied userInfo:nil];

    // 创建并返回信号
    @weakify(self)
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        // 请求访问twitter
        @strongify(self)
        [self.accountStore requestAccessToAccountsWithType:self.twitterAccountType
                                                   options:nil
                                                completion:^(BOOL granted, NSError *error) {
                                                    // 处理响应
                                                    if (!granted)
                                                    {
                                                        [subscriber sendError:accessError];
                                                    }
                                                    else
                                                    {
                                                        [subscriber sendNext:nil];
                                                        [subscriber sendCompleted];
                                                    }
                                                }];
        return nil;
    }];
}
</code></pre>

<p>一个信号可以发送三种事件类型：next, completed, error。</p>

<p>在信号的整个生命周期中，都可能不会发送事件，或者发送一个或多个next事件，其后跟着completed或error事件。</p>

<p>最后，为了使用这个信号，在viewDidLoad中添加以下代码：</p>

<pre><code>[[self requestAccessToTwitterSignal]
 subscribeNext:^(id x) {
     NSLog(@"Access granted");
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>运行程序，可以看到下面的提示</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/RequestAccessToTwitter.png" alt="image" /></p>

<p>如果点击OK，subscribeNext:块中的日志会打印出来。如果点击Don&rsquo;t allow，则会执行错误块并打印期望的信息。</p>

<h2>链接信号</h2>

<p>一旦用户获取了Twitter账户的访问权限，程序需要继续监听搜索框的输入，以查询twitter。程序需要等待请求访问Twitter的信号来发出完成事件，然后订阅广西输入框的信号。不同信号的顺序链接是一个问题，但ReactiveCocoa已经做了很好的处理。</p>

<p>在viewDidLoad中用下面代码来替换当前的管道：</p>

<pre><code>[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>then方法会等到completed事件发出后调用，然后订阅由block参数返回的信号。这有效地将控制从一个信号传递给下一个信号。运行程序，获取访问，然后在输入框输入，会在控制台看到以下输出：</p>

<pre><code>2014-01-04 08:16:11.444 TwitterInstant[39118:a0b] m
2014-01-04 08:16:12.276 TwitterInstant[39118:a0b] ma
2014-01-04 08:16:12.413 TwitterInstant[39118:a0b] mag
2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi
2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic
2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic!
</code></pre>

<p>下一步，我们添加一个filter操作到管道，以移除无效的搜索字符串。在这个实例中，是要求输入长度不小于3：</p>

<pre><code>[[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 filter:^BOOL(NSString *text) {
     @strongify(self)
     return [self isValidSearchText:text];
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>运行后的输出是</p>

<pre><code>2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi
2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic
2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic!
</code></pre>

<p>当前管道如下图所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/PipelineWithThen.png" alt="image" /></p>

<p>现在我们有一个发送搜索文本的信号了，是时候用它来搜索Twitter了。接下来才是正题。</p>

<h2>搜索Twitter</h2>

<p>Social Framework是访问Twitter搜索API的一个选择。但是Social Framework不是响应式的。接下来是封装所需要的API方法到信号中。现在，我们需要挂起这个过程。</p>

<p>在RWSearchFormViewController.m中，添加以下方法：</p>

<pre><code>- (SLRequest *)requestforTwitterSearchWithText:(NSString *)text
{
    NSURL *url = [NSURL URLWithString:@"https://api.twitter.com/1.1/search/tweets.json"];
    NSDictionary *params = @{@"q": text};

    SLRequest *request = [SLRequest requestForServiceType:SLServiceTypeTwitter
                                            requestMethod:SLRequestMethodGET
                                                      URL:url
                                               parameters:params];
    return request;
}
</code></pre>

<p>这个方法通过<a href="https://dev.twitter.com/docs/api/1.1">v1.1 REST API</a>创建了一个搜索Twitter的请求。关于这个API，可以在<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets">Twitter API docs</a>中查看更多信息。</p>

<p>接下来创建一个基于请求的信号。在同一文件中，添加以下代码：</p>

<pre><code>- (RACSignal *)signalForSearchWithText:(NSString *)text {
    // 定义错误
    NSError *noAccountError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorNoTwitterAccounts userInfo:nil];

    NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain code:RWTwitterInstantErrorInvalidResponse userInfo:nil];

    // 创建信号block
    @weakify(self)
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        @strongify(self)

        // 创建请求
        SLRequest *request = [self requestforTwitterSearchWithText:text];

        // 提供Twitter账户
        NSArray *twitterAccounts = [self.accountStore accountsWithAccountType:self.twitterAccountType];
        if (twitterAccounts.count == 0) {
            [subscriber sendError:noAccountError];
        } else {
            [request setAccount:[twitterAccounts lastObject]];

            // 执行请求
            [request performRequestWithHandler:^(NSData *responseData, NSHTTPURLResponse *urlResponse, NSError *error) {
                if (urlResponse.statusCode == 200) {
                    // 成功，解析响应
                    NSDictionary *timelineData = [NSJSONSerialization JSONObjectWithData:responseData options:NSJSONReadingAllowFragments error:nil];
                    [subscriber sendNext:timelineData];
                    [subscriber sendCompleted];
                } else {
                    // 失败，发送一个错误
                    [subscriber sendError:invalidResponseError];
                }
            }];
        }

        return nil;
    }];
}
</code></pre>

<p>现在我们来使用这个新信号。</p>

<p>在第一部分中我们学习了如何使用flattenMap来将每个next事件映射到一个新的被订阅的信号。这里我们再次使用它们。在viewDidLoad的最后用如下代码更新：</p>

<pre><code>[[[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 filter:^BOOL(NSString *text) {
     @strongify(self)
     return [self isValidSearchText:text];
 }]
 flattenMap:^RACStream *(NSString *text ) {
     @strongify(self)
     return [self signalForSearchWithText:text];
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>运行并在搜索框中输入一些文本。一旦文本字符串长度大于3后，我们可以在控制台查看搜索的结果。如下显示了返回数据的一个片断：</p>

<pre><code>2014-01-05 07:42:27.697 TwitterInstant[40308:5403] {
    "search_metadata" =     {
        "completed_in" = "0.019";
        count = 15;
        "max_id" = 419735546840117248;
        "max_id_str" = 419735546840117248;
        "next_results" = "?max_id=419734921599787007&amp;q=asd&amp;include_entities=1";
        query = asd;
        "refresh_url" = "?since_id=419735546840117248&amp;q=asd&amp;include_entities=1";
        "since_id" = 0;
        "since_id_str" = 0;
    };
    statuses =     (
                {
            contributors = "&lt;null&gt;";
            coordinates = "&lt;null&gt;";
            "created_at" = "Sun Jan 05 07:42:07 +0000 2014";
            entities =             {
                hashtags = ...
</code></pre>

<p>signalForSearchText:方法同样发出了一个error事件，其由subscribeNext:error:块来处理。</p>

<h2>线程</h2>

<p>现在一定想把返回的JSON数据显示到UI上了吧，不过，在此之前我们还有一件事情需要处理。要了解这是什么，我们还需要探索一下。</p>

<p>在下图的subscribeNext:error:中打个断点：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/BreakpointLocation.png" alt="image" /></p>

<p>重新运行程序，如果需要则再次输入Twitter账号密码，在搜索框中输入一些文本。当程序运行到断点位置时可以看到类似于下图的场景：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/BreakpointResult.png" alt="image" /></p>

<p>注意，从左侧的线程列表中我们可以看到debugger到的代码并没有运行在主线程，即线程Thread 1。记住，更新UI的操作一定得在主线程中操作；因此，如果要在UI上显示tweet列表，则必须切换线程。</p>

<p>这说明了ReactiveCocoa框架的一个重要点。上面显示的操作是在信号初始发出事件时的那个线程执行。尝试在管道的其它步骤添加断点，我们会很惊奇的发现它们会运行在多个不同的线程上。</p>

<p>因此，我们应该如何来更新UI呢？当然ReactiveCocoa也为我们解决了这个问题。我们只需要在flattenMap:后面添加deliverOn:操作：</p>

<pre><code>[[[[[[self requestAccessToTwitterSignal]
 then:^RACSignal *{
     @strongify(self)
     return self.searchText.rac_textSignal;
 }]
 filter:^BOOL(NSString *text) {
     @strongify(self)
     return [self isValidSearchText:text];
 }] flattenMap:^RACStream *(NSString *text) {
     @strongify(self)
     return [self signalForSearchWithText:text];
 }]
 deliverOn:[RACScheduler mainThreadScheduler]]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>现在重新运行，此时我们可以看到subscribeNext:error:是运行在主线程了。</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/BreakpointNowOnUIThread.png" alt="image" /></p>

<p>这样我们就可以安全地更新我们的UI了。</p>

<h2>更新UI</h2>

<p>打开RWSearchResultsViewController.h文件，我们可以看到displayTweets:方法，这个方法会让右侧的ViewController来渲染tweet数组。实现非常简单，它只是一个标准UITableView数据源。displayTweets:只需要一个包含RWTweet实例的数组作为参数。我们同样发现RWTweet实例是作为初始工程的一部分提供的。</p>

<p>在subscibeNext:error:步骤中获取到的数据现在是一个NSDictionary，它是在signalForSearchWithText:解析JSON数据时构造的。那么，我们如何处理这个字典的内容呢？</p>

<p>如果看一看<a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets">Twitter API documentation</a>，我们可以发现一个示例响应。在NSDictionary反映了这种结构，所以我们需要找到一个键名为statues的字典，其值为一个tweets数组。具体如何解析我们就不在此说明。这里给个更好的实现方式。</p>

<p>我们现在讲的是ReactiveCocoa及函数式编程。当我们使用函数式API时，数据从一种格式转换到另一种格式会变得更优雅。我们可以使用<a href="https://github.com/ColinEberhardt/LinqToObjectiveC">LinqToObjectiveC</a>来执行这个任务。</p>

<p>我们需要使用Cocoapods来导入LinqToObjectiveC。在配置文件中加入以下代码：</p>

<pre><code>pod 'LinqToObjectiveC', '2.0.0'
</code></pre>

<p>关闭工程，在终端执行pod update命令，完成后在我们的Pods工程中就可以看到LinqToObjectiveC了。</p>

<p>打开RWSearchFormViewController.m并导入以下文件：</p>

<pre><code>#import "RWTweet.h"
#import "NSArray+LinqExtensions.h"
</code></pre>

<p>NSArray+LinqExtensions.h头文件来自于LinqToObjectiveC，并为NSArray添加了许多方法以允许我们使用一个流畅的API来转换、排序、分组及过滤数组的数据。</p>

<p>现在我们使用这些API来更新当前管道操作，在viewDidLoad代码中做如下修改：</p>

<pre><code>[[[[[[self requestAccessToTwitterSignal]
     then:^RACSignal *{
         @strongify(self)
         return self.searchText.rac_textSignal;
     }]
    filter:^BOOL(NSString *text) {
        @strongify(self)
        return [self isValidSearchText:text];
    }]
   flattenMap:^RACStream *(NSString *text) {
       @strongify(self)
       return [self signalForSearchWithText:text];
   }]
  deliverOn:[RACScheduler mainThreadScheduler]]
 subscribeNext:^(NSDictionary *jsonSearchResult) {
     NSArray *statuses = jsonSearchResult[@"statuses"];
     NSArray *tweets = [statuses linq_select:^id(id tweet) {
         return [RWTweet tweetWithStatus:tweet];
     }];
     [self.resultsViewController displayTweets:tweets];
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>如上所看到的，subscribeNext:块首先获取twetts的NSArray对象。linq_select方法通过执行应用于每个数组元素的block来转换NSDictionary字典的数组，并生成一个RWTweet实例的数组。</p>

<p>一旦转换完成，tweets将结果发送给ViewController。</p>

<p>运行程序后我们可以看到以下UI：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FinallyWeSeeTweets.png" alt="image" /></p>

<h2>异步加载图片</h2>

<p>在上图中，我们可以看到每行数据前面有一片空白，这是用来显示用户头像的。RWTweet类已经有一个profileImageUrl属性，它是一个图片的URL地址。为了让UITableTable滑动得更平滑，我们需要让获取指定URL的图片的操作不运行在主线程中。这可以使用GCD或者是NSOperationQueue。不过，ReactiveCocoa同样为我们提供了解决方案。</p>

<p>打开RWSearchResultsViewController.m，添加以下代码：</p>

<pre><code>-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl {

    RACScheduler *scheduler = [RACScheduler
                               schedulerWithPriority:RACSchedulerPriorityBackground];

    return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]];
        UIImage *image = [UIImage imageWithData:data];
        [subscriber sendNext:image];
        [subscriber sendCompleted];
        return nil;
    }] subscribeOn:scheduler];

}
</code></pre>

<p>现在我们应该熟悉这种模式了。以上的方法首先获取一个后台scheduler作为信号执行的线程，而不是主线程。接下来，创建一个下载图片数据的信号并在其有订阅者时创建一个UIImage。最后我们调用subscribeOn:，以确保信号在给定的scheduler上执行。</p>

<p>现在，我们可以更新tableView:cellForRowAtIndex:，在return之前添加以下代码：</p>

<pre><code>cell.twitterAvatarView.image = nil;

[[[self signalForLoadingImage:tweet.profileImageUrl]
  deliverOn:[RACScheduler mainThreadScheduler]]
  subscribeNext:^(UIImage *image) {
   cell.twitterAvatarView.image = image;
  }];
</code></pre>

<p>上面的代码首先重新设置图片，因为重用的单元格可能包含之前的数据。然后创建一个请求信号去获取数据，在deliverOn:中我们将后面的next事件运行在主线程，这样subscribeNext:可以安全运行。</p>

<p>运行后得到如下结果：</p>

<p><img src="http://cdn1.raywenderlich.com/wp-content/uploads/2014/01/AvatarsAtAlast.png" alt="image" /></p>

<h2>节流</h2>

<p>你可能已经发现每次我们输入一个新的字符时，搜索操作都会立即执行。如果我们快速输入，可能会导致程序在一秒钟内执行了多次搜索操作。这当然是不好的，因为：</p>

<ol>
<li>我们多次调用了Twitter搜索API，同时扔掉了大部分结果。</li>
<li>我们不断更新结果会分散用户的注意力。</li>
</ol>


<p>一个更好的方案是如果搜索文本在一个较短时间内没有改变时我们再去执行搜索操作，如500毫秒。ReactiveCocoa框架让这一任务变得相当简单。</p>

<p>打开RWSearchFormViewController.m并更新管道操作：</p>

<pre><code>[[[[[[[self requestAccessToTwitterSignal]
      then:^RACSignal *{
          @strongify(self)
          return self.searchText.rac_textSignal;
      }]
     filter:^BOOL(NSString *text) {
         @strongify(self)
         return [self isValidSearchText:text];
     }]
    throttle:0.5]
   flattenMap:^RACStream *(NSString *text) {
       @strongify(self)
       return [self signalForSearchWithText:text];
   }]
  deliverOn:[RACScheduler mainThreadScheduler]]
 subscribeNext:^(NSDictionary *jsonSearchResult) {
     NSArray *statuses = jsonSearchResult[@"statuses"];
     NSArray *tweets = [statuses linq_select:^id(id tweet) {
         return [RWTweet tweetWithStatus:tweet];
     }];
     [self.resultsViewController displayTweets:tweets];
 } error:^(NSError *error) {
     NSLog(@"An error occurred: %@", error);
 }];
</code></pre>

<p>throttle操作只有在两次next事件间隔指定的时间时才会发送第二个next事件。相当简单吧。运行程序看看效果吧。</p>

<h2>小结</h2>

<p>在庆祝胜利前，看看程序最终的管道是值得的。</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/CompletePipeline.png" alt="image" /></p>

<p>这是一个相当复杂的数据流，但可以作为一个响应管道简洁地表示出来。看起来不错吧。如果使用非响应式技术，你会觉得这会有多复杂呢？在这样一个程序中，数据流的流动又会是多难以理解呢？听起来很麻烦吧。但有了ReactiveCocoa，我们不必再考虑这些了。现在我们知道ReactiveCocoa有多棒了吧。</p>

<p>最后，ReactiveCocoa让使用Model View ViewModel(MVVM)设计模式变成可能。如果有兴趣研究MVVM，可以去网上搜索相关的文章。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/">ReactiveCocoa指南一：信号</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-02T23:03:12+08:00" pubdate data-updated="true">Aug 2<sup>nd</sup>, 2014</time>
        
        
           | <a href="/blog/2014/08/02/reactivecocoazhi-nan-%5B%3F%5D-:xin-hao/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文由Colin Eberhardt发表于raywenderlich，<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1">ReactiveCocoa Tutorial – The Definitive Introduction: Part &frac12;</a></p>

<p>在编写iOS代码时，我们的大部分代码都是在响应一些事件：按钮点击、接收网络消息、属性变化等等。但是这些事件在代码中的表现形式却不一样：如target-action、代理方法、KVO、回调或其它。ReactiveCocoa的目的就是定义一个统一的事件处理接口，这样它们可以非常简单地进行链接、过滤和组合。</p>

<p>ReactiveCocoa结合了一些编程模式：</p>

<ol>
<li>函数式编程：利用高阶函数，即将函数作为其它函数的参数。</li>
<li>响应式编程：关注于数据流及变化的传播。</li>
</ol>


<p>基于以上两点，ReactiveCocoa被当成是函数响应编程(Functional Reactive Programming, FRP)框架。我们将在下面以实例来看看ReactiveCocoa的实用价值。</p>

<h2>Reactive Playground实例</h2>

<p>虽然这是一篇指南性质的文章，但我们将以一个简单的实例来介绍ReactiveCocoa。可以在<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlayground-Starter.zip">这里</a>下载源代码，然后编译并运行以确保程序可以运行。</p>

<p>ReactivePlayground是个非常简单的应用，只有一个用户登录界面。只需要提供正确的用户名及密码，就可以显示一幅可爱的小猫的图片。如下图所示：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image" /></p>

<p>这个工程很简单，所以花几分钟来熟悉一下这个工程。打开RWViewController.m，可以快速查找一下如何设置Sign in按钮可用的代码，以及显示/隐藏signInFailure Label的规则。在简单的实现中，我们能快速定位这些问题，但如果实现很复杂，那可能需要花一些时间来分析代码。</p>

<p>现在，我们有了ReactiveCocoa，它能让代码变得更清晰。来看看它是怎么做到的吧。</p>

<h2>添加ReactiveCocoa框架</h2>

<p>添加ReactiveCocoa框架到我们工程的最简单的方法是使用Cocoapods。我们先关闭ReactivePlayground工程。Cocoapods会创建一个Xcode workspace，它会替代我们的原始工程文件。</p>

<p>首先创建一个名为Podfile的空文件，打开并添加如下信息：</p>

<pre><code>platform :ios, '6.0'
inhibit_all_warnings!
xcodeproj 'RWReactivePlayground'

target :RWReactivePlayground do

    pod 'ReactiveCocoa', '~&gt; 2.3.1'

end

post_install do |installer|
installer.project.targets.each do |target|
puts "#{target.name}"
end
end
</code></pre>

<p>配置完成后保存文件，打开终端并转到工程所在目录，然后输入以下命令：</p>

<pre><code>pod install
</code></pre>

<p>然后终端会有如下输出</p>

<pre><code>Analyzing dependencies
Downloading dependencies
Installing ReactiveCocoa (2.3.1)
Generating Pods project
Pods-RWReactivePlayground-ReactiveCocoa
Pods-RWReactivePlayground
Integrating client project

[!] From now on use `RWReactivePlayground.xcworkspace`.
</code></pre>

<p>这表示已经下载了ReactiveCocoa框架，同时Cocoapods创建了一个Xcode workspace，同时将框架整合到了我们的工程中。打开新生成的workspace文件(RWReactivePlayground.xcworkspace)，将看到如下的工程结构：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/AddedCocoaPods.png" alt="image" /></p>

<p>我们看到有一个命名为ReactivePlayground的工程，这实际上是我们的初始工程，它依赖于Pods工程。做完这一切后，我们就可以开始玩了，哈哈。</p>

<h2>Time to Play</h2>

<p>如上所述，ReactiveCocoa提供了一个标准的接口来处理不同的事件流。在ReactiveCocoa中，这些被统一称为信号，由RACSignal类表示。</p>

<p>打开程序的初始视图控制器RWViewController.m文件，在文件头部导入以下头文件：</p>

<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre>

<p>我们暂时先不替换原来的代码，先看看如何使用ReactiveCocoa。在viewDidLoad方法中加入如下代码：</p>

<pre><code>[self.usernameTextField.rac_textSignal subscribeNext:^(id x) {

    NSLog(@"%@", x);
}];
</code></pre>

<p>运行程序并在用户名输入框中键入&#8221;reactive cocoa&#8221;，我们可以看到控制台会有如下输出：</p>

<pre><code>2014-07-31 15:32:30.890 RWReactivePlayground[9191:60b] r
2014-07-31 15:32:32.007 RWReactivePlayground[9191:60b] re
2014-07-31 15:32:32.289 RWReactivePlayground[9191:60b] rea
2014-07-31 15:32:33.990 RWReactivePlayground[9191:60b] reac
2014-07-31 15:32:34.889 RWReactivePlayground[9191:60b] react
2014-07-31 15:32:35.557 RWReactivePlayground[9191:60b] reacti
2014-07-31 15:32:36.022 RWReactivePlayground[9191:60b] reactiv
2014-07-31 15:32:36.505 RWReactivePlayground[9191:60b] reactive
2014-07-31 15:32:42.328 RWReactivePlayground[9191:60b] reactive 
2014-07-31 15:32:47.223 RWReactivePlayground[9191:60b] reactive c
2014-07-31 15:32:47.794 RWReactivePlayground[9191:60b] reactive co
2014-07-31 15:32:48.191 RWReactivePlayground[9191:60b] reactive coc
2014-07-31 15:32:48.657 RWReactivePlayground[9191:60b] reactive coco
2014-07-31 15:32:49.141 RWReactivePlayground[9191:60b] reactive cocoa
</code></pre>

<p>我们可以看到，每次在text field中输入时，都会执行block中的代码。没有target-action，没有代理，只有信号与block。是不是很棒？</p>

<p>ReactiveCocoa信号发送一个事件流到它们的订阅者中。我们需要知道三种类型的事件：next, error和completed。一个信号可能由于error事件或completed事件而终止，在此之前它会发送很多个next事件。在这一部分中，我们将重点关注next事件。在学习关于error和completed事件前，请仔细阅读第二部分。</p>

<p>RACSignal有许多方法用于订阅这些不同的事件类型。每个方法会有一个或多个block，每个block执行不同的逻辑处理。在上面这个例子中，我们看到subscribeNext:方法提供了一个响应next事件的block。</p>

<p>ReactiveCocoa框架通过类别来为大部分标准UIKit控件添加信号，以便这些控件可以添加其相应事件的订阅，如上面的UITextField包含了rac_textSignal属性。</p>

<p>理论讲得差不多了，我们继续吧！！！</p>

<p>ReactiveCocoa有大量的操作右用于处理事件流。例如，如果我们只对长度大于3的用户名感兴趣，则我们可以使用filter操作。在viewDidLoad中更新我们的代码如下：</p>

<pre><code>[[self.usernameTextField.rac_textSignal filter:^BOOL(id value) {
    NSString *text = value;
    return text.length &gt; 3;
}] subscribeNext:^(id x) {
    NSLog(@"%@", x);
}];
</code></pre>

<p>运行并在用户名输入框中输入&#8221;reactive cocoa&#8221;，我们可以看到控制台会有如下输出：</p>

<pre><code>2014-07-31 15:52:13.558 RWReactivePlayground[9249:60b] reac
2014-07-31 15:52:15.960 RWReactivePlayground[9249:60b] react
2014-07-31 15:52:16.589 RWReactivePlayground[9249:60b] reacti
2014-07-31 15:52:17.158 RWReactivePlayground[9249:60b] reactiv
2014-07-31 15:52:17.807 RWReactivePlayground[9249:60b] reactive
2014-07-31 15:52:18.674 RWReactivePlayground[9249:60b] reactive 
2014-07-31 15:52:19.176 RWReactivePlayground[9249:60b] reactive c
2014-07-31 15:52:19.710 RWReactivePlayground[9249:60b] reactive co
2014-07-31 15:52:20.057 RWReactivePlayground[9249:60b] reactive coc
2014-07-31 15:52:20.530 RWReactivePlayground[9249:60b] reactive coco
2014-07-31 15:52:20.978 RWReactivePlayground[9249:60b] reactive cocoa
</code></pre>

<p>可以看到当长度小于3时，并不执行后续的操作。通过这种方式，我们创建了一个简单的管道。这就是响应式编程的实质，我们将我们程序的功能表示为数据流的形式。我们可以将上述调用表示为以下图例：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/FilterPipeline.png" alt="image" /></p>

<p>从上图中我们可以看到rac_textSignal是事件的初始源头。通过filter的数据流只有在其长度大于3时，才会被传递到下一处理流程中。管道的最后一步是subscribeNext:，在这个block中，我们记录日志。</p>

<p>在这里需要注意的是filter操作的输出仍然是一个RACSignal对象。我们可以将上面这段管道处理拆分成如下代码：</p>

<pre><code>RACSignal *usernameSourceSignal = self.usernameTextField.rac_textSignal;

RACSignal *filteredUsername = [usernameSourceSignal filter:^BOOL(id value) {

    NSString *text = value;
    return text.length &gt; 3;
}];

[filteredUsername subscribeNext:^(id x) {

    NSLog(@"%@", x);
}];
</code></pre>

<p>因为RACSignal对象的每个操作都返回一个RACSignal对象，所以我们不需要使用变量就可以构建一个管道。</p>

<h2>事件是什么</h2>

<p>目前为止，我们已经描述了3种不同的事件类型，但还没有深入这些事件的结构。有趣的是，事件可以包含任何东西。为了证明这一点，我们在上面的管道中加入另一个操作。更新我们的代码：</p>

<pre><code>[[[self.usernameTextField.rac_textSignal map:^id(NSString *text) {
    return @(text.length);
 }]
 filter:^BOOL(NSNumber *length) {
     return [length intValue] &gt; 3;
 }]
 subscribeNext:^(id x) {
     NSLog(@"%@", x);
 }];
</code></pre>

<p>编译并运行，我们会发现控制台输出如下信息：</p>

<pre><code>2014-07-31 16:13:47.652 RWReactivePlayground[9321:60b] 4
2014-07-31 16:13:47.819 RWReactivePlayground[9321:60b] 5
2014-07-31 16:13:47.985 RWReactivePlayground[9321:60b] 6
2014-07-31 16:13:48.134 RWReactivePlayground[9321:60b] 7
2014-07-31 16:13:48.284 RWReactivePlayground[9321:60b] 8
2014-07-31 16:13:48.417 RWReactivePlayground[9321:60b] 9
2014-07-31 16:13:48.583 RWReactivePlayground[9321:60b] 10
2014-07-31 16:13:48.734 RWReactivePlayground[9321:60b] 11
2014-07-31 16:13:48.883 RWReactivePlayground[9321:60b] 12
</code></pre>

<p>新添加的map操作使用提供的block来转换事件数据。对于收到的每一个next事件，都会运行给定的block，并将返回值作为next事件发送。在上面的代码中，map操作获取一个NSString输入，并将其映射为一个NSNumber对象，并返回。下图演示了这个管道处理：</p>

<p><img src="http://cdn2.raywenderlich.com/wp-content/uploads/2014/01/FilterAndMapPipeline.png" alt="image" /></p>

<p>我们可以看到，map操作后的每一步接收的都是一个NSNumber对象。我们可以使用map操作来转换我们想要的数据，只需要它是一个对象。</p>

<p>OK，是时候修改ReactivePlayground应用的代码了。</p>

<h2>创建有效的状态信号</h2>

<p>我们要做的第一件事就是创建一对信号来校验用户名与密码的输入是否有效。添加如下代码到RWViewController.m的viewDidLoad中。</p>

<pre><code>RACSignal *validUsernameSignal = [self.usernameTextField.rac_textSignal map:^id(NSString *text) {
    return @([self isValidUsername:text]);
}];

RACSignal *validPasswordSignal = [self.passwordTextField.rac_textSignal map:^id(NSString *text) {
    return @([self isValidPassword:text]);
}];
</code></pre>

<p>我们使用将map操作应用于文本输入框的rac_textSignal，输出是一个NSNumber对象。接着将转换这些信号，以便其可以为文本输入框提供一个合适的背影颜色。我们可以订阅这个信号并使用其结果来更新文本输入框的颜色。可以如下操作：</p>

<pre><code>[[validPasswordSignal map:^id(NSNumber *passwordValid) {
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}] subscribeNext:^(UIColor *color) {
    self.passwordTextField.backgroundColor = color;
}];
</code></pre>

<p>从概念上讲，我们将信号的输出值赋值给文本输入框的backgroundColor属性。但是这段代码有点糟糕。我们可以以另外一种方式来做相同的处理。这得益于ReactiveCocoa定义的一些宏。如下代码所示：</p>

<pre><code>RAC(self.passwordTextField, backgroundColor) = [validPasswordSignal map:^id(NSNumber *passwordValid) {
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];

RAC(self.usernameTextField, backgroundColor) = [validUsernameSignal map:^id(NSNumber *passwordValid) {
    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];
}];
</code></pre>

<p>RAC宏我们将信号的输入值指派给对象的属性。它带有两个参数，第一个参数是对象，第二个参数是对象的属性名。每次信号发送下一个事件时，其输出值都会指派给给定的属性。这是个非常优雅的解决方案，对吧？</p>

<p>在运行前，我们先找到updateUIState方法，并注释掉下面两行代码：</p>

<pre><code>self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];
self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor];
</code></pre>

<p>运行程序，我们可以看到当输入无效时文本输入框是高亮的，有效时则清除高亮。在这里，我们可以看到两条带有文本信号的简单的管道，都是将它们映射到标明是否有效的布尔对象，然后再映射到UIColor对象。如下图所示：</p>

<p><img src="http://cdn5.raywenderlich.com/wp-content/uploads/2014/01/TextFieldValidPipeline.png" alt="image" /></p>

<h2>组合信号</h2>

<p>在当前的程序中，Sign in按钮只有在两个输入框都有效时才可点击。是时候处理这个响应了。</p>

<p>当前代码有两个信号来标识用户名和密码是否有效：validUsernameSignal和validPasswordSignal。我们的任务是要组合这两个信号，来确定按钮是否可用。</p>

<p>在viewDidLoad中添加下面的代码</p>

<pre><code>RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]
                                                  reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid){

                                                      return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);
                                                  }];
</code></pre>

<p>上面的代码使用了combineLatest:reduce:方法来组合validUsernameSignal与validPasswordSignal最后输出的值，并生成一个新的信号。每次两个源信号中的一个输出新值时，reduce块都会被执行，而返回的值会作为组合信号的下一个值。</p>

<p><em>注意：RACSignal组合方法可以组合任何数量的信号，而reduce块的参数会对应每一个信号。</em></p>

<p>现在我们已以有了一个合适的信号，接着在viewDidLoad结尾中添加以下代码，这将信号连接到按钮的enabled属性。</p>

<pre><code>[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) {

    self.signInButton.enabled = [signupActive boolValue];
}];
</code></pre>

<p>同样，在运行前移除以下代码：</p>

<pre><code>@property (nonatomic) BOOL passwordIsValid;
@property (nonatomic) BOOL usernameIsValid;
</code></pre>

<p>同时移除viewDidLoad中以下代码：</p>

<pre><code>[self.usernameTextField addTarget:self action:@selector(usernameTextFieldChanged) forControlEvents:UIControlEventEditingChanged];
[self.passwordTextField addTarget:self action:@selector(passwordTextFieldChanged) forControlEvents:UIControlEventEditingChanged];
</code></pre>

<p>当然我们还需要移除updateUIState, usernameTextFieldChanged和passwordTextFieldChanged方法及相关的调用。瞧，我们已经删除了不少代码了。感谢自己吧！</p>

<p>运行，并检查Sign in按钮。如同之前一下，如果用户名和密码都有效，则按钮是可用的。</p>

<p>更新后程序的逻辑如下图所示：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/CombinePipeline.png" alt="image" /></p>

<p>上面我们已经用ReactiveCocoa实现了一些非常棒的功能，它包含了两个重要的概念：</p>

<ol>
<li>Spliting: 信号可以有多个订阅者，且作为资源服务于序列化管道的多个步骤。</li>
<li>Combining: 多个信号可以组合起来创建新的信号。</li>
</ol>


<p>在上面的程序中，这些改变让程序不再需要私有属性，来标明两个输入域的有效状态。这是使用响应式编程的关键区别&mdash;我们不需要使用实例变量来跟踪短暂的状态。</p>

<h2>响应Sign-in</h2>

<p>程序目前使用了响应式管道来管理输入框与按钮的状态。按钮的点击操作仍然使用target-action。所以，这是我们下一步的目标。</p>

<p>Sign-in按钮的Touch Up Inside事件通过storyboard action连接到RWViewController.m的signInButtonTouched方法中。我们现在使用响应式方法来替换它，所以第一步我们需要解除当前storyboard action的连接。这个自己处理吧。</p>

<p>为了处理按钮事件，我们需要使用ReactiveCocoa添加到UIKit的另一个方法：rac_signalForControlEvents。我们在viewDidLoad结尾加入以下代码：</p>

<pre><code>[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {

    NSLog(@"Button clicked");
}];
</code></pre>

<p>上面的代码从按钮的UIControlEventTouchUpInside事件中创建一个信号，并添加订阅以在每次事件发生时添加日志。</p>

<p>运行程序，当按钮可点时点击按钮，会记录以下日志：</p>

<pre><code>2014-07-31 17:45:43.660 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.493 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.660 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.810 RWReactivePlayground[9617:60b] Button clicked
2014-07-31 17:45:44.944 RWReactivePlayground[9617:60b] Button clicked
</code></pre>

<p>现在点击事件有一个信号了，接下来将信号与登录处理连接起来。打开RWDummySignInService.h文件，我们会看到下面的接口：</p>

<pre><code>typedef void (^RWSignInResponse)(BOOL);

@interface RWDummySignInService : NSObject

- (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock;

@end
</code></pre>

<p>这个方法带有一个用户名、密码和一个完成block。block会在登录成功或失败时调用。我们可以在subscribeNext:块中直接调用这个方法，但为什么不呢？因为这是一个异步操作，小心了。</p>

<h2>创建信号</h2>

<p>幸运的是，将一个已存在的异步API表示为一个信号相当简单。我们来看看。</p>

<p>首先，从RWViewController.m移除当前的signInButtonTouched:方法。我们通过响应式编程来取代它。</p>

<p>在RWViewController.m中添加以下方法：</p>

<pre><code>- (RACSignal *)signInSignal
{
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

        [self.signInService signInWithUsername:self.usernameTextField.text
                                      password:self.passwordTextField.text
                                      complete:^(BOOL success) {
                                          [subscriber sendNext:@(success)];
                                          [subscriber sendCompleted];
                                      }];
        return nil;
    }];
}
</code></pre>

<p>上面的代码创建了一个使用当前用户名与密码登录的信号。现在我们来分解一下这个方法。createSignal:方法用于创建一个信号。描述信号的block是一个信号参数，当信号有一个订阅者时，block中的代码会被执行。</p>

<p>block传递一个实现RACSubscriber协议的subscriber(订阅者)，这个订阅者包含我们调用的用于发送事件的方法；我们也可以发送多个next事件，这些事件由一个error事件或complete事件结束。在上面这种情况下，它发送一个next事件来表示登录是否成功，后续是一个complete事件。</p>

<p>这个block的返回类型是一个RACDisposable对象，它允许我们执行一些清理任务，这些操作可能发生在订阅取消或丢弃时。上面这个这个信号没有任何清理需求，所以返回nil。</p>

<p>可以看到，我们就这样在信号中封装了一个异步API。现在，我们可以使用这个新的信号了，更新viewDidLoad中我们的代码吧：</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] map:^id(id value) {
    return [self signInButton];
}] subscribeNext:^(id x) {
    NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>上面的代码使用map方法将按钮点击信号转换为登录信号。订阅者简单输出了结果。</p>

<p>运行程序，点击按钮，可以看到以下输出：</p>

<pre><code>2014-07-31 18:29:27.134 RWReactivePlayground[9749:60b] Sign in result: &lt;UIButton: 0x13651ed40; frame = (192 201; 76 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x178224c00&gt;&gt;
</code></pre>

<p>可以看到subscribeNext:块传递了一个正确的信号，但结果不是登录信号。我们用图来展示这个管道操作：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/SignalOfSignals.png" alt="image" /></p>

<p>当点击按钮时rac_signalForControlEvents发出了一个next事件。map这一步创建并返回一个登录信号，意味着接下来的管理接收一个RACSignal。这是我们在subscribeNext:中观察到的对象。</p>

<p>上面这个方案有时候称为信号的信号(signal of signals)，换句话说，就是一个外部信号包含一个内部信号。可以在输出信号的subscribeNext:块中订阅内部信号。但这会引起嵌套的麻烦。幸运的是，这是个普遍的问题，而ReactiveCocoa已经提供了解决方案。</p>

<h2>Signal of Signals</h2>

<p>这个问题有解决方案是直观的，只需要使用flattenMap来替换map。如下代码所示：</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) {
    return [self signInSignal];
}] subscribeNext:^(id x) {
    NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>这将按钮点击事件映射到一个登录信号，但同时通过将事件从内部信号发送到外部信号，使这个过程变得扁平化。再次运行程序，我们将得到以下的输出</p>

<pre><code>2014-07-31 18:46:19.535 RWReactivePlayground[9785:60b] Sign in result: 1
</code></pre>

<p>这回对了。</p>

<p>现在管道处理得到了我们想要的结果，最后我们在subscriptNext中添加登录处理逻辑。使用以下代码：</p>

<pre><code>[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside] flattenMap:^RACStream *(id value) {
    return [self signInSignal];
}] subscribeNext:^(NSNumber *signedIn) {

    BOOL success = [signedIn boolValue];
    self.signInFailureText.hidden = success;
    if (success)
    {
        [self performSegueWithIdentifier:@"signInSuccess" sender:self];
    }
}];
</code></pre>

<p>运行程序，我们就可以得到下面的结果了：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/ReactivePlaygroundStarter.jpg" alt="image" /></p>

<p>不知道你是否注意到一个细节问题。当点击登录进行验证时，我们应该置灰登录按钮。这样可以阻止用户在验证的过程中再次去点击登录。那么这个逻辑添加在哪呢？改变按钮的可用状态不是个转换、过滤或其它的信号。这就是下一步要讲的。</p>

<h2>添加附加操作(side-effects)</h2>

<p>使用下面的代码替换当前管道：</p>

<pre><code>[[[[self.signInButton rac_signalForControlEvents:UIControlEventTouchUpInside]
 doNext:^(id x) {
     self.signInButton.enabled = NO;
     self.signInFailureText.hidden = YES;
 }]
 flattenMap:^RACStream *(id value) {
     return [self signInSignal];
 }]
 subscribeNext:^(NSNumber *signedIn) {
     self.signInButton.enabled = YES;
     BOOL success = [signedIn boolValue];
     self.signInFailureText.hidden = success;
     if (success) {
         [self performSegueWithIdentifier:@"signInSuccess" sender:self];
     }
 }];
</code></pre>

<p>我们可以看到在按钮点击事件后添加了doNext:步骤。注意doNext:并不返回一个值，因为它是附加操作。它完成时不改变事件。下图展示了这个过程：</p>

<p><img src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/01/SideEffects.png" alt="image" /></p>

<p>运行程序看看效果。如何？</p>

<p>注意：在执行异步方法时禁用按钮是个普遍的问题，ReactiveCocoa同样解决了这个问题。<strong>RACCommand</strong>类封装了这个概念，同时有一个enabled信号以允许我们将一个按钮的enabled属性连接到信号。可以试试。</p>

<h2>小结</h2>

<p>ReactiveCocoa的核心是信号，它是一个事件流。使用ReactiveCocoa时，对于同一个问题，可能会有多种不同的方法来解决。ReactiveCocoa的目的就是为了简化我们的代码并更容易理解。如果使用一个清晰的管道，我们可以很容易理解问题的处理过程。在下一部分，我们将会讨论错误事件的处理及完成事件的处理。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/01/core-bluetoothkuang-jia-zhi-san-:zui-jia-shi-jian/">Core Bluetooth框架之三：最佳实践</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-01T23:03:22+08:00" pubdate data-updated="true">Aug 1<sup>st</sup>, 2014</time>
        
        
           | <a href="/blog/2014/08/01/core-bluetoothkuang-jia-zhi-san-:zui-jia-shi-jian/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在iOS设备中使用BLE时，无论是将其作为central端还是peripheral端，其在通信时都会使用设备自身的无线电来发送信号。考虑到其它形式的无线通信也需要使用无线电，因此开发程序时应该尽量少使用无线电。另外，这对于设备电池的寿命及程序的性能也有所帮助。以此为出发点，我们将介绍一些使用BLE时的最佳实践，希望有所帮助。</p>

<h2>与Peripheral设备交互的最佳实践</h2>

<p>Core Bluetooth框架让程序的大部分Central端交互变得透明。即程序能够控制且有责任实现大部分Central端的操作，如设备搜索及连接，解析并与远程peripheral数据交互。下面我们将介绍一些Central端的最佳实践。</p>

<h4>留意无线电的使用及电量消耗</h4>

<h5>只有当需要时才扫描设备</h5>

<p>当调用CBCentralManager类的scanForPeripheralsWithServices:options:方法来搜索正在广告服务的peripheral设备时，central设备使用无线电来监听广告的设备，直到我们显示停止它。除非需要搜索更多的设备，否则当发现想要连接的设备时就停止扫描操作。此时可以调用CBCentralManager实例的stopScan方法来处理。</p>

<h5>只有当需要时才指定CBCentralManagerScanOptionAllowDuplicatesKey选项</h5>

<p>远程peripheral设备可能每秒发送多个广告包来声明它们的存在。当我们使用scanForPeripheralsWithServices:options:方法扫描设备时，该方法的默认行为是将多个搜索到的广告peripheral事件归集为一个事件&mdash;即central管理器在只有在每次发现新的peripheral时都调用其代理对象的centralManager:didDiscoverPeripheral:advertisementData:RSSI:，而不管它收到多少个广告包。central管理器在已发现的peripheral改变广告的数据时也会调用这个代理方法。</p>

<p>如果想要改变默认行为，可以指定CBCentralManagerScanOptionAllowDuplicatesKey作为扫描选项。此时，central管理器会在每次收到peripheral端的广告包时都触发一个事件。在某些情况下关闭默认行为很有用处，但记住指定CBCentralManagerScanOptionAllowDuplicatesKey扫描选项不利于电池的寿命及程序性能。因此，只在需要的时候使用这个选项以完成特定的任务。</p>

<h5>解析peripheral数据</h5>

<p>一个peripheral设备可能有多个服务和特性，但在我们的应用中，可能只对其中一些感兴趣。搜索peripheral设备的所有服务和特性可能不利于电池的寿命及程序性能。因此，我们只去搜索那些与我们的的应用相关的服务和特性。</p>

<p>例如，假设我们正在连接一个有很多可用服务的peripheral设备，但是我们的程序只需要访问其中两个。我们可以只查找这两个服务，即在调用CBPeripheral对象的discoverServices:方法时传入感兴趣服务的UUID的数组即可。如下代码所示：</p>

<pre><code>[peripheral discoverServices:@[firstServiceUUID, secondServiceUUID]];
</code></pre>

<p>在搜索到这两个感兴趣的服务后，我们可以用类似的方法去搜索我们感兴趣的服务中的特性。此时调用CBPeripheral实例的discoverCharacteristics:forService:方法并传入特性UUID的数组。</p>

<h5>订阅经常改变的特性值</h5>

<p>我们可以通过两种方式获取特性的值：</p>

<ol>
<li>在我们每次需要值时调用readValueForCharacteristic:方法来显示的轮循特性的值</li>
<li>调用setNotifyValue:forCharacteristic:方法来订阅特性的值，这样当值改变时我们可以收到来自于peripheral的通知。</li>
</ol>


<p>通常最好是去订阅特性的值，特别是特性值经常改变时。</p>

<h5>当获取到所有需要的数据时断开到设备的连接</h5>

<p>当连接不再需要时，我们可以断开连接，以减少无线电的使用。在下面两种情况下，我们应该断开连接：</p>

<ol>
<li>所有订阅的特性值已经停止发送通知(我们可以访问特性的isNotifying属性来查看属性值是否正在被通知)</li>
<li>我们已以获取来来自peripheral设备的全部值。</li>
</ol>


<p>两种情况下，取自我们有的所有订阅并断开连接。我们通过调用setNotifyValue:forCharacteristic:方法并设置第一个参数为NO来取消订阅。同时调用CBCentralManager实例的cancelPeripheralConnection:方法来断开连接。注意这个cancelPeripheralConnection:方法是非阻塞的，如果我们尝试断开连接的peripheral设备仍然挂起，则CBPeripheral实例的命令可能完成执行，也可能没有。因为其它程序可能也连接着那个peripheral设备。取消一个本地连接不能保证底层物理链接会立即断开。</p>

<h4>重新链接Peripheral</h4>

<p>使用Core Bluetooth框架，有三种方式来重新连接peripheral设备：</p>

<ol>
<li>使用retrievePeripheralsWithIdentifiers:方法获取已知peripheral设备的列表，这些设备是我们已经搜索并连接过的设备。如果我们查找的peripheral在列表中，则尝试重新连接。</li>
<li>使用retrieveConnectedPeripheralsWithServices:方法获取当前连接到系统的peripheral设备的列表。如果我们查找的peripheral设备在列表中，则连接它。</li>
<li>使用scanForPeripheralsWithServices:options:方法扫描并搜索peripheral设备。如果找到，则连接它。</li>
</ol>


<p>根据使用的场景，我们可能不希望每次重新连接设备时，都去扫描并搜索设备。相反，我们可能想首先使用其它方式来重新连接。如下图所示，一个可能的重新连接操作流是按照上面列出来的方式去重新连接：</p>

<h5>获取已知peripheral设备的列表</h5>

<p>我们第一次发现一个peripheral设备时，系统生成一个标识符(NSUUID对象)来标识peripheral设备。我们可以存储这些设备，后续我们可以使用CBCentralManager实例的retrievePeripheralsWithIdentifiers:方法来重新连接这个peripheral设备。</p>

<p>当我们启动程序时，调用retrievePeripheralsWithIdentifiers:方法，传递一个我们先前搜索并连接过的peripheral设备的标识符的数组，如下代码所示：</p>

<pre><code>knownPeripherals = [myCentralManager retrievePeripheralsWithIdentifiers:savedIdentifiers];
</code></pre>

<p>central管理器尝试在这个列表中匹配我们提供的标识符，并返回一个CBPeripheral对象的数组。如果没找到，则返回的数组为空，那么我们需要尝试另外两种方法。如果返回的数组不为空，则让用户选择连接哪一个peripheral设备。当用户选择后，调用CBCentralManager实例的connectPeripheral:options:方法来尝试连接。如果peripheral设备仍然可以连接，则central管理器调用代理对象的centralManager:didConnectPeripheral:方法，且成功连接上peripheral设备。</p>

<h5>获取已连接peripheral设备的列表</h5>

<p>另一种重新连接peripheral设备的方法是查看我们正在查找的设备是否正由系统连接着(如被其它程序连接着)。我们可以调用CBCentralManager实例的retrieveConnectedPeripheralsWithServices:方法，它返回一个表示当前系统正在连接着的peripheral设备的CBPeripheral对象的数组。</p>

<p>因为可以有多于一个peripheral设备正在连接着系统，我们可以传递一个CBUUID对象的数组来获取只包含指定UUID所标识服务的设备。如果当前系统没有连接任何peripheral设备，则返回数组为空，我们应该尝试其它两种方法。如果返回数组不为空，则让用户选择连接哪个设备。</p>

<p>假设用户找到并选择了需要的peripheral设备，则调用CBCentralManager实例的connectPeripheral:options:方法来连接它(即使系统已经连接了它，我们的程序仍然需要连接它以开始解析并交互数据)。当连接建立后，central管理器调用代理对象的centralManager:didConnectPeripheral:方法，然后成功连接peripheral设备。</p>

<h2>将本地设备设置为peripheral设备的最佳实践</h2>

<h4>广告注意事项</h4>

<p>在设置本地设备作为peripheral端时，广告peripheral数据是非常重要的一部分。我们下面将介绍一下如何以适当的方式来实现这一功能。</p>

<p>我们广告peripheral数据时，是将其放在一个字典中传递给CBPeripheralManager对象的startAdvertising:方法中。当创建一个广告字典时，需要知道我们可以广告什么及能广告多少数据。</p>

<p>虽然广告数据包通常可以放置关于peripheral设备的多种信息，但建议只放置设备的本地名及我们需要广告的服务的UUID。即，当创建广告字典时，可能只指定下面两个键：CBAdvertisementDataLocalNameKey和CBAdvertisementDataServiceUUIDsKey。如果指定其它键，则会收到一个错误。</p>

<p>同样，广告数据时也限定了可以使用多少空间。当程序在前台时，可广告的数据对于上述两个key值的任意组合来说，初始值不能超过28个字节。如果这个空间用完了，在扫描响应时可以有额外的10个字节的空间，但这只能用于本地名。任何超出的数据都会被放到一个指定的“溢出”区域；它们只能被显示扫描它们的iOS设备发现。当程序在后台时，本地名不能被广告，且所有的服务UUID都被放在溢出区域。</p>

<p>为了符合这此限制条件，我们需要将广告的服务UUID限制在主要服务的标识上。</p>

<p>另外，因为广告peripheral数据使用本地设备的无线电，所以只在需要其它设备连接的时候广告数据。一旦连接后，这些设备可以直接解析并交互数据，而不需要任何广告包。因此，为了减少无线电的使用、提高程序的性能及节省电量，当不再需要任何试图进行BLE交易时可以停止广告。为了停止本地peripheral，可以调用CBPeripheralManager对象的stopAdvertising方法，如下所示：</p>

<pre><code>[myPeripheralManager stopAdvertising];
</code></pre>

<p>通常，只有用户才知道什么时候广告数据。例如，当我们知道没有任何BLE设备在附近时，在我们的设备上广告服务没有任何意义。因为我们的程序通常不知道是否有其它设备在附近，所以提供一个界面让用户来决定什么时候广告数据。</p>

<h4>配置特性</h4>

<p>当创建一个可变的特性时，我们设置它的属性、值和权限。这些设置决定了如何连接central访问及交互特性值。虽然我们可能基于程序的需求来配置特性的属性和权限，但当执行下面两种任务时，我们还是有章可循的</p>

<ol>
<li>允许连接的central订阅属性</li>
<li>保护敏感特性值，不让其被未配对的central访问</li>
</ol>


<p>对于这两种情况，首先我们配置特性以支持通知。通常建议central去订阅那些经常改变的特性值。当我们创建一个可变特性时，可以通过使用CBCharacteristicPropertyNotify常量来设置特性属性以支持订阅，如下所示：</p>

<pre><code>myCharacteristic = [[CBMutableCharacteristic alloc] initWithType:myCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable];
</code></pre>

<p>在这个例子中，特性值是可读的，且可以被连接的central端订阅。</p>

<p>其它，要求配对的连接才能访问敏感数据。根据场景的不同，我们可能想要提供一个服务，这个服务有一个或多个需要加密值的特性。例如，假设我们想要提供一个社交媒体配置文件服务。这个服务有一些特性，它们的值表示成员的配置信息，如姓名、电子邮件地址。更可能的是，我们只允许受信任的设备来获取成员的电子邮件地址。</p>

<p>我们可以设置合适的特性属性及权限来确保只有受信任的设备可以访问敏感的特性值。继续上面的例子，为了只允许受信任的设备来获取成员的邮箱地址，可以如下设置合适的特性属性与权限：</p>

<pre><code>emailCharacteristic = [[CBMutableCharacteristic alloc] initWithType:emailCharacteristicUUID properties:CBCharacteristicPropertyRead | CBCharacteristicPropertyNotifyEncryptionRequired value:nil permissions:CBAttributePermissionsReadEncryptionRequired];
</code></pre>

<p>在这个例子中，特性配置为只有受信任的设备才可以读取或订阅它的值。当一个连接的central尝试读取或订阅特性值时，Core Bluetooth尝试配对本地peripheral和central端来创建安全连接。</p>

<p>例如，如果central和peripheral都是iOS设备，两端都接收一个提示显示对方想要配对。central设备上的提示包含包含一个确认码，这个确认码必须在peripheral设备提示框的输入域中输入，来完成配对操作。</p>

<p>在配对成功后，peripheral认为配对的central是一个受信任的设备且允许central访问它的加密特性值。</p>

<h2>小结</h2>

<p>在使用BLE时，基于以下几点，程序开发过程中我们合理地使用蓝牙</p>

<ol>
<li>程序性能</li>
<li>电池电量消耗</li>
<li>与其它通信方法争抢无线电资源</li>
</ol>


<p>通常我们只在需要时才使用BLE，尽量减少设备扫描搜索操作。</p>

<h2>参考</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth Programming Guide</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/31/core-bluetoothkuang-jia-zhi-er-:hou-tai-chu-li/">Core Bluetooth框架之二：后台处理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-31T23:28:24+08:00" pubdate data-updated="true">Jul 31<sup>st</sup>, 2014</time>
        
        
           | <a href="/blog/2014/07/31/core-bluetoothkuang-jia-zhi-er-:hou-tai-chu-li/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在开发BLE相关应用时，由于应用在后台时会有诸多资源限制，需要考虑应用的后台处理问题。默认情况下，当程序位于后台或挂起时，大多数普通的Core Bluetooth任务都无法使用，不管是Central端还是Peripheral端。但我们可以声明我们的应用支持Core Bluetooth后台执行模式，以允许程序从挂起状态中被唤醒以处理蓝牙相关的事件。</p>

<p>然而，即使我们的应用支持两端的Core Bluetooth后台执行模式，它也不能一直运行。在某些情况下，系统可能会关闭我们的应用来释放内存，以为当前前台的应用提供更多的内存空间。在iOS7及后续版本中，Core Bluetooth支持保存Central及Peripheral管理器对象的状态信息，并在程序启动时恢复这些信息。我们可以使用这个特性来支持与蓝牙设备相关的长时间任务。</p>

<p>下面我们将详细讨论下这些问题。</p>

<h2>只支持前台操作(Foreground-Only)的应用</h2>

<p>大多数应用在进入到后台后都会在短时间内进入挂起状态，除非我们请求执行一些特定的后台任务。当处理挂起状态时，我们的应用无法继续执行蓝牙相关的任务。</p>

<p>在Central端，Foreground-Only应用在进入后台或挂起时，无法继续扫描并发现下在广告的Peripheral设备。而在Peripheral端，无法广告自身，同时Central端对其的任何访问操作都会返回一个错误。</p>

<p>Foreground-Only应用挂起时，所有蓝牙相关的事件都会被系统放入一个队列，当应用进入前台后，系统会将这些事件发送给我们的应用。也就是说，当某些事件发生时，Core Bluetooth提供了一种方法来提示用户。用户可以使用这些提示来决定是否将应用放到前台。在《Core Bluetooth框架之一：Central与Peripheral》中我们介绍了connectPeripheral:options:方法，在调用这个方法时，我们可以设备options参数来设置这些提示：</p>

<ol>
<li>CBConnectPeripheralOptionNotifyOnConnectionKey：当应用挂起时，如果有一个连接成功时，如果我们想要系统为指定的peripheral显示一个提示时，就使用这个key值。</li>
<li>CBConnectPeripheralOptionNotifyOnDisconnectionKey：当应用挂起时，如果连接断开时，如果我们想要系统为指定的peripheral显示一个断开连接的提示时，就使用这个key值。</li>
<li>CBConnectPeripheralOptionNotifyOnNotificationKey：当应用挂起时，使用该key值表示只要接收到给定peripheral端的通知就显示一个提示。</li>
</ol>


<h2>Core Bluetooth后台执行模式</h2>

<p>我们可以在Info.plist文件中设置Core Bluetooth后台执行模式，以让应用支持在后台执行一些蓝牙相关的任务。当应用声明了这一功能时，系统会将应用唤醒以允许它处理蓝牙相关的任务。这个特性对于与那种定时发送数据的BLE交互的应用非常有用。</p>

<p>有两种Core Bluetooth后台执行模式，一种用于实现Central端操作，一种用于实现Peripheral端操作。如果我们的应用同时实现了这两端的功能，则需要声明同时支持两种模式。我们需要在Info.plist文件添加UIBackgroundModes键，同时添加以下两个值或其中之一：</p>

<ol>
<li>bluetooth-central(App communicates using CoreBluetooth)</li>
<li>bluetooth-peripheral(App shares data using CoreBluetooth)</li>
</ol>


<h4>bluetooth-central模式</h4>

<p>如果设置了bluetooth-central值，则我们的应用在后台时，仍然可以查找并连接到Peripheral设备，以及查找相应数据。另外，系统会在CBCentralManagerDelegate或CBPeripheralDelegate代理方法被调用时唤醒我们的应用，允许应用处理事件，如建立连接或断开连接等等。</p>

<p>虽然应用在后台时，我们可以执行很多蓝牙相关任务，但需要记住应用在前后台扫描Peripheral设备时还是不一样的。当我们的应用在后台扫描Peripheral设备时，</p>

<ol>
<li>CBCentralManagerScanOptionAllowDuplicatesKey扫描选项会被忽略，同一个Peripheral端的多个发现事件会被聚合成一个发现事件。</li>
<li>如果扫描Peripheral设备的多个应用都在后台，则Central设备扫描广告数据的时间间隔会增加。结果是发现一个广告的Peripheral设备可能需要很长时间。</li>
</ol>


<p>这些处理在iOS设备中最小化无线电的使用及改善电池的使用寿命非常有用。</p>

<h4>bluetooth-peripheral模式</h4>

<p>如果设置了bluetooth-peripheral值，则我们的应用在后台时，应用会被唤醒以处理来自于连接的Central端的读、写及订阅请求，Core Bluetooth还允许我们在后台进行广告。与Central端类似，也需要注意前后台的操作区别。特别是在广告时，有以下几点区别：</p>

<ol>
<li>CBAdvertisementDataLocalNameKey广告key值会被忽略，Peripheral端的本地名不会被广告</li>
<li>CBAdvertisementDataServiceUUIDsKey键的所有服务的UUID都被放在一个&#8221;overflow&#8221;区域中，它们只能被那些显示要扫描它们的网络设备发现。</li>
<li>如果多个应用在后台广告，则Peripheral设备发送广告包的时间间隔会变长。</li>
</ol>


<h2>在后台执行长(Long-Term)任务</h2>

<p>虽然建议尽快完成后台任务，但有些应该仍然需要使用Core Bluetooth来执行一个长任务。这时就涉及到状态的保存与恢复操作。</p>

<h4>状态保存与恢复</h4>

<p>因为状态保存与恢复是内置于Core Bluetooth的，我们的程序可以选择这个特性，让系统保存Central和Peripheral管理器的状态并继续执行一些蓝牙相关的任务，即使此时程序不再运行。当这些任务中的一个完成时，系统会在后台重启程序，程序可以恢复先前的状态以处理事件。Core Bluetooth支持Central端、Peripheral端的状态保存与恢复，也可以同时支持两者。</p>

<p>在Central端，系统会在关闭程序释放内存时保存Central管理器对象的状态(如果有多个Central管理器，我们可以选择系统跟踪哪个管理器)。对于给定的CBCentralManager对象，系统会跟踪如下信息：</p>

<ol>
<li>Central管理器扫描的服务</li>
<li>Central管理器尝试或已经连接的Peripheral</li>
<li>Central管理器订阅的特性</li>
</ol>


<p>在Peripheral端，对于给定的CBPeripheralManager对象，系统会跟踪以下信息：</p>

<ol>
<li>Peripheral管理器广告的数据</li>
<li>Peripheral管理器发布到设备数据库的服务和特性</li>
<li>订阅Peripheral管理器的特性值的Central端</li>
</ol>


<p>当系统将程序重启到后台后，我们可以重新重新初始化我们程序的Central和Peripheral管理器并恢复状态。我们接下来将详细介绍一下如何使用状态保存与恢复。</p>

<h4>添加状态保存和恢复支持</h4>

<p>Core Bluetooth中的状态保存与恢复是可选的特性，需要程序的支持才能工作。我们可以按照以下步骤来添加这一特性的支持：</p>

<ol>
<li>(必要步骤)当分配及初始化Central或Peripheral管理器对象时，选择性加入状态保存与恢复。</li>
<li>(必要步骤)在系统重启程序时，重新初始化Central或Peripheral管理器对象</li>
<li>(必要步骤)实现适当的恢复代理方法</li>
<li>(可选步骤)更新Central或Peripheral管理器初始化过程</li>
</ol>


<h5>选择性加入状态保存与恢复</h5>

<p>为了选择性加入状态保存与恢复特性，在分配及初始化Central或Peripheral管理器时提供一个一个唯一恢复标识。<strong>恢复标识</strong>是一个字条串，用来让Core Bluetooth和程序标识Central或Peripheral管理器。字符串的值只在自己的代码中有意义，但这个字符串告诉Core Bluetooth我们需要保存对象的状态。Core Bluetooth只保存那些有恢复标识的对象。</p>

<p>例如，在实现Central端时，为了选择性加入状态保存与恢复特性，在初始化CBCentralManager对象时，可以指定初始化选项CBCentralManagerOptionRestoreIdentifierKey，并提供一个恢复标识，如下代码所示：</p>

<pre><code>centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:@{CBCentralManagerOptionRestoreIdentifierKey: @"restoreIdentifier"}];
</code></pre>

<p>实现Peripheral端时的操作也类似，只不过我们使用选项CBPeripheralManagerOptionRestoreIdentifierKey键。</p>

<p>因为程序可以有多个Central或Peripheral管理器，所以需要确保恢复标识是唯一的，这样系统可以区分这些管理器对象。</p>

<h5>重新初始化Central或Peripheral管理器对象</h5>

<p>当系统重启程序到后台后，我们所需要做的第一件事就是使用恢复标识来重新初始化这些对象。如果我们的应用只有一个Central管理器或Peripheral管理器，且管理器在程序的整个生命周期都存在，则后续我们便不需要再做更多的处理。但如果我们有多个管理器，或者管理器不是存在于程序的整个生命周期，则系统重启应用时，我们需要知道重新初始化哪一个管理器。我们可以通过在程序代理对象的application:didFinishLaunchingWithOptions:方法中，使用合适的启动选项键来访问管理器对象的列表(这个列表是程序关闭是系统为程序保存的)。</p>

<p>下面代码展示了程序重新启动时，我们获取所有Central管理器对象的恢复标识:</p>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    // Override point for customization after application launch.

    NSArray *centralManagerIdentifiers = launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey];

    // TODO: ...

    return YES;
}
</code></pre>

<p>有了这个恢复标识的列表后，我们就可以重新初始化我们所需要的管理器对象了。</p>

<h5>实现适当的恢复代理方法</h5>

<p>重新初始化Central或Peripheral管理器对象后，我们通过使用蓝牙系统的状态同步这些对象的状态来恢复它们。此时，我们需要实现一些恢复代理方法。对于Central管理器，我们实现centralManager:willRestoreState:代理方法；对于Peripheral管理器管理器，我们实现peripheralManager:willRestoreState:代理方法。</p>

<p><em>对于选择性加入保存与恢复特性的应用来说，这些方法是程序启动到后台以完成一些蓝牙相关任务所调用的第一个方法。而对于非选择性加入特性的应用来说，会首先调用centralManagerDidUpdateState:和peripheralManagerDidUpdateState:代理方法。</em></p>

<p>在上述两个代理方法中，最后一个参数是一个字典，包含程序关闭时保存的关于管理器的信息。如下代码所示，我们可以使用CBCentralManagerRestoredStatePeripheralsKey键来获取Central管理器已连接的或尝试连接的所有Peripheral设备的列表:</p>

<pre><code>- (void)centralManager:(CBCentralManager *)central willRestoreState:(NSDictionary *)state
{
    NSArray *peripherals = state[CBCentralManagerRestoredStatePeripheralsKey];

    // TODO: ...
}
</code></pre>

<p>获取到这个列表后，我们便可以根据需要来做处理。</p>

<h5>更新初始化过程</h5>

<p>在实现了前面的三个步骤后，我们可能想更新我们的管理器的初始化过程。虽然这一步是可选的，但如果要确认任务是否运行正常时，非常有用。例如，我们的程序可能在解析所连接的Peripheral设备的数据的过程中被关闭。当程序使用这个Peripheral设备作恢复操作时，无法知道数据处理到哪了。我们需要确保程序从数据操作停止的位置继续开始操作。</p>

<p>又如下面的代码展示了在centralManagerDidUpdateState:代理方法中初始化程序操作时，我们可以找出是否成功发现了被恢复的Peripheral设备的指定服务：</p>

<pre><code>NSUInteger serviceUUIDIndex = [peripheral.services indexOfObjectPassingTest:^BOOL(CBService *obj, NSUInteger index, BOOL *stop) {        return [obj.UUID isEqual:myServiceUUIDString];    }];
    if (serviceUUIDIndex == NSNotFound) {       [peripheral discoverServices:@[myServiceUUIDString]];       ...
}    
</code></pre>

<p>如上例所述，如果系统在程序完成搜索服务时关闭了应用，则通过调用discoverServices:方法在关闭的那个点开始解析恢复的Peripheral数据。如果程序成功搜索到服务，我们可以确认是否搜索到正确的特性。通过更新初始化过程，我们可以确保在正确的时间调用正确的方法。</p>

<h2>小结</h2>

<p>虽然我们可能需要声明应用支持Core Bluetooth后台执行模式，以完成特定的任务，但总是应该慎重考虑执行后台操作。因为执行太多的蓝牙相关任务需要使用iOS设备的内置无线电，而无线电的使用会影响到电池的寿命，所以尽量减少在后台执行的任务。任何会被蓝牙相关任务唤醒的应用应该尽快处理任务并在完成时重新挂起。</p>

<p>下面是一些基础的准则：</p>

<ol>
<li>应用应该是基于会话的，并提供接口以允许用户决定什么时候开始及结束蓝牙相关事件的分发。</li>
<li>一旦被唤醒，一个应用大概有10s的时间来完成任务。理想情况下，应用应该尽快完成任务并重新挂起。系统可以对执行时间太长的后台任务进行限流甚至杀死。</li>
<li>应用被唤醒时，不应该执行一些无关紧要的操作。</li>
</ol>


<h2>参考</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth Programming Guide</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/9">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/7">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
<section>
<h1>分类</h1>
<ul>
  <li><a href='/blog/categories/ios'>ios (58)</a></li>
  <li><a href='/blog/categories/network'>network (3)</a></li>
  <li><a href='/blog/categories/reactivecocoa'>reactivecocoa (3)</a></li>
  <li><a href='/blog/categories/swift'>swift (7)</a></li>
  <li><a href='/blog/categories/system'>system (1)</a></li>
  <li><a href='/blog/categories/网络'>网络 (8)</a></li>
</ul>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">翻译篇：iOS 8 Handoff Tutorial</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/11/nscache/">NSCache</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/07/yuan-ma-pian-:sdwebimage/">源码篇：SDWebImage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/nsobjectzhi-er/">NSObject之二</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/nsobjectzhi-%5B%3F%5D/">NSObject之一</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/25/gong-ju-pian-:lldbdiao-shi-qi/">工具篇：LLDB调试器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/yuan-ma-pian-:mantle/">源码篇：Mantle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/gong-ju-pian-:mantle/">工具篇：Mantle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-san-:pdfwen-dang-de-chuang-jian-,-xian-shi-ji-zhuan-huan/">Quartz 2D编程指南之十三：PDF文档的创建、显示及转换</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-er-:core-graphicsceng-hui-zhi/">Quartz 2D编程指南之十二：Core Graphics层绘制</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 南峰子 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  











</body>
</html>

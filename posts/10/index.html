
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>南峰子的技术博客</title>
  <meta name="author" content="南峰子">
      
  <meta name="baidu-site-verification" content="HoscFhWICI" />

  
  <meta name="description" content="原文发表在cocoachina上，现在把它整理过来。 Cover Flow介绍 Cover flow是苹果首创的将多首歌曲的封面以3D界面的形式显示出来的方式。 随处可见的Cover Flow特效 iTunes:在iTunes音乐中点击搜索框左边“查看”项第三个，即以cover &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://southpeak.github.io/posts/10">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="南峰子的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!-- <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> -->
  <!-- googleapis is fucked by gfw -->
  <script src="http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">南峰子的技术博客</a></h1>
  
    <h2>攀登，一步一个脚印，方能知其乐</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:southpeak.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/categories/ios">iOS开发</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/18/cover-flowte-xiao-shi-xian/">Cover Flow特效实现</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-18T22:12:57+08:00" pubdate data-updated="true">Jul 18<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/07/18/cover-flowte-xiao-shi-xian/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.cocoachina.com/bbs/read.php?tid=74500">原文</a>发表在cocoachina上，现在把它整理过来。</p>

<h2>Cover Flow介绍</h2>

<p>Cover flow是苹果首创的将多首歌曲的封面以3D界面的形式显示出来的方式。</p>

<p><img src="http://www.cocoachina.com/bbs/attachment/Fid_6/6_38018_be3432a30663e7e.png" alt="image" /></p>

<h4>随处可见的Cover Flow特效</h4>

<p>iTunes:在iTunes音乐中点击搜索框左边“查看”项第三个，即以cover flow形式显示专辑封面（前提是你得添加插图或音乐自带插图），也可以在全屏模式使用</p>

<p>iPhone/iPod Touch:在竖屏模式播放音乐，iPhone只会显示一张专辑的封面；但当用户将机身旋转为横屏模式后，则能看到多首歌曲的封面以3D界面的形式显示出来，用手指左右的滑动能够进行歌曲的选择，点击相应的专辑封面则会显示该张唱片的曲目，点击相应歌曲即可开始播放。</p>

<p>苹果官网:官网上有以Flash展示的cover flow界面iPod NANO3/4/5:基本类似于在iphone中的操作，利用触摸轮滑动使封面转换Safari</p>

<p>使用 Cover Flow，您可以像在 iTunes 中翻看专辑插图一样轻松地翻看网站。Cover Flow 可以将您的书签和历史记录显示为大图预览，这样您就能立即找到网站。要查看 Cover Flow 如何工作，请单击 Safari“书签”栏左端的打开书本图标来打开书签列表。在“精选”列表中选择“历史记录”或您要查看其标签的精选。使用水平滚动条来翻看网页预览。您还可以使用鼠标上的滚动按钮来翻看预览。如果您的触控板已配置为支持触控板手势，则您可以左右扫动。</p>

<h2>特效制作</h2>

<h4>方法一：UICoverFlowLayer</h4>

<p>正式的SDK并未包含UICoverFlowLayer，但是它仍然是标准的uikit。通过steve nygard的类转储(class-dump), 能从uikit框架中提取 UICoverFlowLayer头文件。</p>

<p>由于UICoverFlowLayer是私有的，无法应用于应用程序(无法通过苹果的审查)，所以在此简单介绍使用方法：</p>

<ol>
<li>将UICoverFlowLayer.h文件拷贝到工程中创建cover flow视图，并将UICoverFlowLayer图层分配到视图图层中</li>
<li>视图发送dragFlow:atPoint消息，以处理与Cover Flow图层的触摸和拖动的交互过程构建cover flow视图控制器，分配和初始化视图，并提供委托和数据源方法</li>
</ol>


<p>使用UICoverFlowLayer的方法如下代码所示</p>

<pre><code>UICoverFlowLayer *cfLayer = [[UICoverFlowLayer alloc] initWithFrame:frame numberOfCovers:count];

[[self layer] addSublayer:cfLayer];
</code></pre>

<h4>方法二：OpenFlow</h4>

<p>OpenFlow是一个用于实现Cover Flow特效的开源库，它是基于Quartz实现的，能很好的实现Cover Flow特效，同时又易于使用。</p>

<p>下载地址：<a href="https://github.com/thefaj/OpenFlow">https://github.com/thefaj/OpenFlow</a></p>

<p>使用OpenFlow的基本步骤如下：</p>

<ol>
<li>创建工程</li>
<li>添加OpenFlow源代码到工程中</li>
<li>添加QuartzCore和CoreGraphics框架到工程中</li>
<li>定义CoverFlowViewController(自定义)类</li>
<li>在CoverFlowViewController.h中导入”AFOpenFlowView.h”</li>
<li>实现AFOpenFlowViewDelegate类和AFOpenFlowDataSource协议</li>
</ol>


<p>定义CoverFlowViewController类的代码如下所示</p>

<pre><code>//  CoverFlowViewController.h
//  CoverFlow
//
//  Created by Avinash on 4/7/10.
//  Copyright Apple Inc 2010. All rights reserved.
//

#import "AFOpenFlowView.h"
@interface CoverFlowViewController : UIViewController  {
    // Queue to hold the cover flow p_w_picpath
    NSOperationQueue *loadImagesOperationQueue;
}
@end
</code></pre>

<p>实现CoverFlowViewController类</p>

<p>加载图片</p>

<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
     // loading p_w_picpath into the queue
    loadImagesOperationQueue = [[NSOperationQueue alloc] init];
    NSString *imageName;
    for (int i=0; i &lt; 10; i++) {
        imageName = [[NSString alloc] initWithFormat:@"cover_%d.jpg", i];
        [(AFOpenFlowView *)self.view setImage:[UIImage imageNamed:imageName] forIndex:i];
        [imageName release];
        NSLog(@"%d is the index",i); 
   }
    [(AFOpenFlowView *)self.view setNumberOfImages:10];
}
</code></pre>

<p>实现委托方法，以设置Cover Flow默认图片及通知哪幅图片被选中</p>

<pre><code>//delegate protocols
// delegate protocol to tell which image is selected
- (void)openFlowView:(AFOpenFlowView *)openFlowView selectionDidChange:(int)index{
    NSLog(@"%d is selected",index);
}
// setting the image 1 as the default pic
- (UIImage *)defaultImage{
    return [UIImage imageNamed:@"cover_1.jpg"];
}
</code></pre>

<p>修改xib文件中视图的类UIView为AFOpenFlowView(重要)</p>

<p>完成上述步骤之后，就可以运行一下程序看一下效果了。虽然与苹果的Cover Flow效果还是有点差距，但还是不错哦。</p>

<h4>方法三：FlowCover</h4>

<p>FlowCover也是一个开源库，它是基于OpenGL ES。FlowCover的源代码非常简单，只有FlowCoverView和DataCache两个类。这两个类的功能如下：</p>

<ol>
<li>FlowCoverView：定义主视图。这是一个OpenGL ES视点，可以被嵌套在其它视图中。</li>
<li>DataCache：提供一个简单的数据缓存方案，保存一定量的对象，当对象超过最大值时，旧的对象会被舍弃。</li>
</ol>


<p>使用FlowCover的基本步骤如下：</p>

<ol>
<li>创建工程</li>
<li>添加FlowCover源代码到工程中</li>
<li>然后就可以像用其它UIView一样使用FlowCoverView了</li>
</ol>


<p>FlowCover中需要实现FlowCoverViewDelegate协议，该协议中主要有三个方法：</p>

<pre><code>-(int)flowCoverNumberImages:(FlowCoverView *)view;
</code></pre>

<p>返回FlowCoverView视图中显示的图片数量</p>

<pre><code>-(UIImage *)flowCover:(FlowCoverView *)view cover:(int)cover;
</code></pre>

<p>返回FlowCoverView视图中用cover指定的图片</p>

<pre><code>-(void)flowCover:(FlowCoverView *)view didSelect:(int)cover;
</code></pre>

<p>当用户触击FlowCoverView中的cover时调用。</p>

<h4>方法四：Tapku框架</h4>

<p>Tapku库是一个开源的iOS框架，它包含CoverFlow, Calendar Grid, Char View等等API，总之还是一个比较强大的库。把Tapku加下工程中还是比较复杂的，有兴趣的童鞋可以去网上搜一下。</p>

<p>Tapku下载地址：<a href="https://github.com/devinross/tapkulibrary">https://github.com/devinross/tapkulibrary</a></p>

<p>Tapku中与Cover Flow相关的类主要有如下两个：</p>

<ol>
<li>TKCoverflowCoverView: 该类表示的是单个cover。相当于UITableViewCell</li>
<li>TKCoverflowView:该类相当于UITableView类，用来管理和显示cover flow中图片及实现cover flow效果。</li>
</ol>


<p>同时还有两个相关的协议：TKCoverflowViewDelegate， TKCoverflowViewDataSource，分别是 TKCoverflowView的代理及数据源。这两个协议分别有一个必须实现的方法，分别是
TKCoverflowViewDelegate协议的</p>

<pre><code>- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasBroughtToFront:(int)index;
</code></pre>

<p>TKCoverflowViewDataSource协议的</p>

<pre><code>- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasDoubleTapped:(int)index
</code></pre>

<p>在工程中使用Tapku的CoverFlow步骤如下</p>

<ol>
<li>创建工程</li>
<li>添加Tapku库到工程中(该步骤有点麻烦，而且Tapku库比较大，个人认为可以只把CoverFlow相关的类抽取出来直接用)。</li>
<li>新建一个视图控制器CoverflowViewController，在该控制器中添加如下代码</li>
</ol>


<p>在头文件CoverflowViewController.h中</p>

<pre><code>@interface CoverflowViewController : UIViewController &lt;TKCoverflowViewDelegate,TKCoverflowViewDataSource,UIScrollViewDelegate&gt; {
    TKCoverflowView *coverflow; 
    NSMutableArray *covers; // album covers p_w_picpath
    ......
}
</code></pre>

<p>在CoverflowViewController.m文件中主要有如下处理</p>

<pre><code>//创建视图
- (void) loadView{
   [super loadView];
    ......
    coverflow = [[TKCoverflowView alloc] initWithFrame:self.view.bounds];
    coverflow.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    coverflow.coverflowDelegate = self;
    coverflow.dataSource = self;
    if([UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPad){
       coverflow.coverSpacing = 100;
      coverflow.coverSize = CGSizeMake(300, 300);
    }
    [self.view addSubview:coverflow];
   ......
}
</code></pre>

<p>实现代理方法</p>

<pre><code>- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasBroughtToFront:(int)index{
}
//生成单个cover flow
- (TKCoverflowCoverView*) coverflowView:(TKCoverflowView*)coverflowView coverAtIndex:(int)index{
    TKCoverflowCoverView *cover = [coverflowView dequeueReusableCoverView];
    if(cover == nil){
       BOOL phone = [UIDevice currentDevice].userInterfaceIdiom == UIUserInterfaceIdiomPhone;
       CGRect rect = phone ? CGRectMake(0, 0, 224, 300) : CGRectMake(0, 0, 300, 600);

      cover = [[[TKCoverflowCoverView alloc] initWithFrame:rect] autorelease]; // 224
       cover.baseline = 224;  
    }
    cover.image = [covers objectAtIndex:index%[covers count]];
   return cover;
}
- (void) coverflowView:(TKCoverflowView*)coverflowView coverAtIndexWasDoubleTapped:(int)index{
   TKCoverflowCoverView *cover = [coverflowView coverAtIndex:index];
    if(cover == nil) return;
    [UIView beginAnimations:nil context:nil];
    [UIView setAnimationDuration:1];
    [UIView setAnimationTransition:UIViewAnimationTransitionFlipFromLeft forView:cover cache:YES];
    [UIView commitAnimations];
   NSLog(@"Index: %d",index);
}
</code></pre>

<h2>效果比较</h2>

<p>在效果上个人感觉Tapku会好些，渲染流畅，美中不足的是在快速拖动时，停止下来的时候会有抖动的感觉（当然快速拖动这一功能是否需要可视情况而定，如果将此功能禁掉，跟苹果自身的效果还是差不多的）。</p>

<p>OpenFlow的问题在于当改变图像时，新选中的图像会先放大并置于表层，然后才缓动到中间。这是其一个瑕疵。</p>

<p>总体感觉上来讲，苹果自身的CoverFlow的缓动效果还是最好的，有那种渐进渐出的效果，而如上几个开源的库其动画显得有点生硬，有兴趣的童鞋可以试着改进一下。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/17/ioszhong-liu-stream-de-shi-yong/">iOS中流(Stream)的使用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-17T23:30:26+08:00" pubdate data-updated="true">Jul 17<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/07/17/ioszhong-liu-stream-de-shi-yong/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>流提供了一种简单的方式在不同和介质中交换数据，这种交换方式是与设备无关的。流是在通信路径中串行传输的连续的比特位序列。从编码的角度来看，流是单向的，因此流可以是输入流或输出流。除了基于文件的流外，其它形式的流都是不可查找的，这些流的数据一旦消耗完后，就无法从流对象中再次获取。</p>

<p>在Cocoa中包含三个与流相关的类：NSStream、NSInputStream和NSOutputStream。NSStream是一个抽象基类，定义了所有流对象的基础接口和属性。NSInputStream和NSOutputStream继承自NSStream，实现了输入流和输出流的默认行为。下图描述了流的应用场景：</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Articles/Art/stream_src_dest.gif" alt="image" /></p>

<p>从图中看，NSInputStream可以从文件、socket和NSData对象中获取数据；NSOutputStream可以将数据写入文件、socket、内存缓存和NSData对象中。这三处类主要处理一些比较底层的任务。</p>

<p>流对象有一些相关的属性。大部分属性是用于处理网络安全和配置的，这些属性统称为SSL和SOCKS代理信息。两个比较重要的属性是：</p>

<ol>
<li>NSStreamDataWrittenToMemoryStreamKey：允许输出流查询写入到内存的数据</li>
<li>NSStreamFileCurrentOffsetKey：允许操作基于文件的流的读写位置</li>
</ol>


<p>可以给流对象指定一个代理对象。如果没有指定，则流对象作为自己的代理。流对象调用唯一的代理方法stream:handleEvent:来处理流相关的事件：</p>

<ol>
<li>对于输入流来说，是有可用的数据可读取事件。我们可以使用read:maxLength:方法从流中获取数据</li>
<li>对于输出流来说，是准备好写入的数据事件。我们可以使用write:maxLength:方法将数据写入流</li>
</ol>


<p>Cocoa中的流对象与Core Foundation中的流对象是对应的。我们可以通过toll-free桥接方法来进行相互转换。NSStream、NSInputStream和NSOutputStream分别对应CFStream、CFReadStream和CFWriteStream。但这两者间不是完全一样的。Core Foundation一般使用回调函数来处理数据。另外我们可以子类化NSStream、NSInputStream和NSOutputStream，来自定义一些属性和行为，而Core Foundation中的流对象则无法进行扩展。</p>

<p>上面主要介绍了iOS中流的一些基本概念，我们下面将介绍流的具体使用，首先看看如何从流中读取数据。</p>

<h2>从输入流中读取数据</h2>

<p>从一个NSInputStream流中读取数据主要包括以下几个步骤：</p>

<ol>
<li>从数据源中创建和初始化一个NSInputStream实例</li>
<li>将流对象放入一个run loop中并打开流</li>
<li>处理流对象发送到其代理的事件</li>
<li>当没有更多数据可读取时，关闭并销毁流对象。</li>
</ol>


<h4>准备流对象</h4>

<p>要使用一个NSInputStream，必须要有数据源。数据源可以是文件、NSData对象和网络socket。创建好后，我们设置其代理对象，并将其放入到run loop中，然后打开流。代码清单1展示了这个准备过程.</p>

<h6>代理清单1</h6>

<pre><code>- (void)setUpStreamForFile:(NSString *)path
{
    NSInputStream *inputStream = [[NSInputStream alloc] initWithFileAtPath:path];
    inputStream.delegate = self;
    [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];

    [inputStream open];
}
</code></pre>

<p>在流对象放入run loop且有流事件(有可读数据)发生时，流对象会向代理对象发送stream:handleEvent:消息。在打开流之前，我们需要调用流对象的scheduleInRunLoop:forMode:方法，这样做可以避免在没有数据可读时阻塞代理对象的操作。我们需要确保的是流对象被放入正确的run loop中，即放入流事件发生的那个线程的run loop中。</p>

<h4>处理流事件</h4>

<p>打开流后，我们可以使用streamStatus属性查看流的状态，用hasBytesAvailable属性检测是否有可读的数据，用streamError来查看流处理过程中产生的错误。</p>

<p>流一旦打开后，将会持续发送stream:handleEvent:消息给代理对象，直到流结束为止。这个消息接收一个NSStreamEvent常量作为参数，以标识事件的类型。对于NSInputStream对象，主要的事件类型包括NSStreamEventOpenCompleted、NSStreamEventHasBytesAvailable和NSStreamEventEndEncountered。通常我们会对NSStreamEventHasBytesAvailable更感兴趣。代理清单2演示了从流中获取数据的过程</p>

<h6>代理清单2</h6>

<pre><code>- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode
{
    switch (eventCode) {
        case NSStreamEventHasBytesAvailable:
        {
            if (!data) {
                data = [NSMutableData data];
            }

            uint8_t buf[1024];
            unsigned int len = 0;
            len = [(NSInputStream *)aStream read:buf maxLength:1024];  // 读取数据
            if (len) {
                [data appendBytes:(const void *)buf length:len];
            }
        }
            break;
    }
}
</code></pre>

<p>当NSInputStream在处理流的过程中出现错误时，它将停止流处理并产生一个NSStreamEventErrorOccurred事件给代理。我们同样的上面的代理方法中来处理这个事件。</p>

<h4>清理流对象</h4>

<p>当NSInputStream读取到流的结尾时，会发送一个NSStreamEventEndEncountered事件给代理，代理对象应该销毁流对象，此过程应该与创建时相对应，代码清单3演示了关闭和释放流对象的过程。</p>

<h6>代理清单3</h6>

<pre><code>- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode
{
    switch (eventCode) {
        case NSStreamEventEndEncountered:
        {
            [aStream close];
            [aStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];
            aStream = nil;
        }
            break;
    }
}
</code></pre>

<h2>写入数据到输出流</h2>

<p>类似于从输入流读取数据，写入数据到输出流时，需要下面几个步骤：</p>

<ol>
<li>使用要写入的数据创建和初始化一个NSOutputStream实例，并设置代理对象</li>
<li>将流对象放到run loop中并打开流</li>
<li>处理流对象发送到代理对象中的事件</li>
<li>如果流对象写入数据到内存，则通过请求NSStreamDataWrittenToMemoryStreamKey属性来获取数据</li>
<li>当没有更多数据可供写入时，处理流对象</li>
</ol>


<p>基本流程与输入流的读取差不多，我们主要介绍不同的地方</p>

<ol>
<li>数据可写入的位置包括文件、C缓存、程序内存和网络socket。</li>
<li>hasSpaceAvailable属性表示是否有空间来写入数据</li>
<li>在stream:handleEvent:中主要处理NSStreamEventHasSpaceAvailable事件，并调用流的write:maxLength方法写数据。代码清单4演示了这一过程。</li>
<li>如果NSOutputStream对象的目标是应用的内存时，在NSStreamEventEndEncountered事件中可能需要从内存中获取流中的数据。我们将调用NSOutputStream对象的propertyForKey:的属性，并指定key为NSStreamDataWrittenToMemoryStreamKey来获取这些数据。</li>
</ol>


<h6>代理清单4</h6>

<pre><code>- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode
{
    switch (eventCode) {
        case NSStreamEventHasSpaceAvailable:
        {
            uint8_t *readBytes = (uint8_t *)[data mutableBytes];
            readBytes += byteIndex;
            int data_len = [data length];
            unsigned int len = (data_len - byteIndex &gt;= 1024) ? 1024 : (data_len - byteIndex);
            uint8_t buf[len];

            (void)memcpy(buf, readBytes, len);

            len = [aStream write:(const uint_8 *)buf maxLength:len];
            byteIndex += len;
            break;
        }
    }
}
</code></pre>

<p>这里需要注意的是：当代理接收到NSStreamEventHasSpaceAvailable事件而没有写入任何数据到流时，代理将不再从run loop中接收该事件，直到NSOutputStream对象接收到更多数据，这时run loop会重启NSStreamEventHasSpaceAvailable事件。</p>

<h2>流的轮循处理</h2>

<p>在流的处理过程中，除了将流放入run loop来处理流事件外，还可以对流进行轮循处理。我们将流处理数据的过程放到一个循环中，并在循环中不断地去询问流是否有可用的数据供读取(hasBytesAvailable)或可用的空间供写入(hasSpaceAvailable)。当处理到流的结尾时，我们跳出循环结束流的操作。</p>

<p>具体的过程如代码清单5所示</p>

<p>代码清单5</p>

<pre><code>- (void)createNewFile {
    NSOutputStream *oStream = [[NSOutputStream alloc] initToMemory];
    [oStream open];

    ￼￼￼uint8_t *readBytes = (uint8_t *)[data mutableBytes];
    uint8_t buf[1024];
    int len = 1024;

    while (1) {
        if (len == 0) break;

        if ([oStream hasSpaceAvailable])
        {
            (void)strncpy(buf, readBytes, len);
            readBytes += len;
            if ([oStream write:(const uint8_t *)buf maxLength:len] == -1)
            {
                [self handleError:[oStream streamError]];
                break;
            }
            [bytesWritten setIntValue:[bytesWritten intValue]+len];
            len = (([data length] - [bytesWritten intValue] &gt;= 1024) ? 1024 : [data length] - [bytesWritten intValue]);
        }
    }
    NSData *newData = [oStream propertyForKey:NSStreamDataWrittenToMemoryStreamKey];

    if (!newData) {
        NSLog(@"No data written to memory!");
    } else {
        [self processData:newData];
    }

    [oStream close];
    [oStream release];
    oStream = nil;
}
</code></pre>

<p>这种处理方法的问题在于它会阻塞当前线程，直到流处理结束为止，才继续进行后面的操作。而这种问题在处理网络socket流时尤为严重，我们必须等待服务端数据回来后才能继续操作。因此，通常情况下，建议使用run loop方式来处理流事件。</p>

<h2>错误处理</h2>

<p>当流出现错误时，会停止对流数据的处理。一个流对象在出现错误时，不能再用于读或写操作，虽然在关闭前可以查询它的状态。</p>

<p>NSStream和NSOutputStream类会以几种方式来告知错误的发生：</p>

<ol>
<li>如果流被放到run loop中，对象会发送一个NSStreamEventErrorOccurred事件到代理对象的stream:handleEvent:方法中</li>
<li>任何时候，可以调用streamStatus属性来查看是否发生错误(返回NSStreamStatusError)</li>
<li>如果在通过调用write:maxLength:写入数据到NSOutputStream对象时返回-1，则发生一个写错误。</li>
</ol>


<p>一旦确定产生错误时，我们可以调用流对象的streamError属性来查看错误的详细信息。在此我们不再举例。</p>

<h2>设置Socket流</h2>

<p>在iOS中，NSStream类不支持连接到远程主机，幸运的是CFStream支持。前面已经说过这两者可以通过toll-free桥接来相互转换。使用CFStream时，我们可以调用CFStreamCreatePairWithSocketToHost函数并传递主机名和端口号，来获取一个CFReadStreamRef和一个CFWriteStreamRef来进行通信，然后我们可以将它们转换为NSInputStream和NSOutputStream对象来处理。</p>

<p>具体的处理流程我们会在后期详细讨论。</p>

<p>参考</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Streams.html">Stream Programming Guide</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/16/urljia-zai-xi-tong-zhi-si-:ren-zheng-yu-tlslian-yan-zheng/">URL加载系统之四：认证与TLS链验证</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-16T18:51:03+08:00" pubdate data-updated="true">Jul 16<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/07/16/urljia-zai-xi-tong-zhi-si-:ren-zheng-yu-tlslian-yan-zheng/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>一个NSURLRequest对象经常会遇到认证请求，或者需要从其所连接的服务端请求证书。当需要认证请求时，NSURLConnection、NSURLSession和NSURLDownload类会通知它们的代理对象，以便能正确地做处理。不过需要注意的是，URL加载系统只有在服务端响应包含WWW-Authenticate头时才会调用代理来处理认证请求，而类似于代理认证和TLS信任验证这样的认证类型则不需要这个头。</p>

<h2>确定如何响应一个认证请求</h2>

<p>如果一个NSURLRequest对象需要认证时，则认证请求方式取决于使用的对象的类型：</p>

<ol>
<li>如果请求是与NSURLSession对象关联，则所有认证请求都会传递给代理，而不考虑认证的类型。</li>
<li>如果请求是与NSURLConnection或NSURLDownload对象，则对象的代理接收一个connection:canAuthenticateAgainstProtectionSpace: (或者 download:canAuthenticateAgainstProtectionSpace:) 消息。这允许代理对象在尝试再次认证前分析服务端的属性，包括协议和认证方法。如果我们的代理对象不准备认证服务端的受保护空间，则返回NO，且系统尝试使用用户的keychain的信息进行认证。</li>
<li>如果NSURLConnection或NSURLDownload的代理对象没有实现connection:canAuthenticateAgainstProtectionSpace: (或者 download:canAuthenticateAgainstProtectionSpace:)方法，且保护空间使用客户端证书认证或服务端信任认证，则系统假设我们返回NO。而对象其它所有类型，系统都返回YES。</li>
</ol>


<p>下一步，如果我们的代理对象同意处理认证，但是没有有效的证书（不管是作为请求URL的一部分或者在NSURLCredentialStorage中共享），则代理以收到以下消息：</p>

<ol>
<li>URLSession:didReceiveChallenge:completionHandler:2. URLSession:task:didReceiveChallenge:completionHandler:3. connection:didReceiveAuthenticationChallenge:4. download:didReceiveAuthenticationChallenge:</li>
</ol>


<p>为了让连接能够继续，则代理对象有三种选择：</p>

<ol>
<li>提供认证证书</li>
<li>尝试在没有证书的情况下继续</li>
<li>取消认证查询</li>
</ol>


<p>为了确保操作的正确流程，传递给这些方法的NSURLAuthenticationChallenge实例会包含一些信息，包括是什么触发了认证查询、查询的尝试次数、任何先前尝试的证书、请求证书的NSURLProtectionSpace对象，及查询的发送者。</p>

<p>如果认证请求事先尝试认证且失败了(如用户在服务端修改了密码)，我们可以通过在认证请求调用proposedCredential来获取尝试凭据。代理可以使用这些证书来填充一个显示给用户的话框。</p>

<p>调用认证请求的previousFailureCount可以返回身份验证尝试次数，这些尝试包括不同认证协议的尝试请求。代理可以将这些方法提供给用户，以确定先前提供的证书是否失败，或限制最大认证尝试次数。</p>

<h2>响应认证请求</h2>

<p>前面说过三种响应我们响应connection:didReceiveAuthenticationChallenge:代理方法的方式，我们将逐一介绍：</p>

<h4>提供证书</h4>

<p>为了进行认证，程序需要使用服务端期望的认证信息创建一个NSURLCredential对象。我们可以调用authenticationMethod来确定服务端的认证方法，这个认证方法是在提供的认证请求的保护空间中。NSURLCredential支持一些方法：</p>

<ol>
<li>HTTP基本认证(NSURLAuthenticationMethodHTTPBasic)：需要用户名和密码。提示用户输入必要信息并使用credentialWithUser:password:persistence:方法创建一个NSURLCredential对象。</li>
<li>HTTP数字认证(NSURLAuthenticationMethodHTTPDigest):类似于基本认证，需要用户名和密码。提示用户输入必要信息并使用credentialWithUser:password:persistence:方法创建一个NSURLCredential对象。</li>
<li>客户端证书认证(NSURLAuthenticationMethodClientCertificate): 需要系统标识和所有服务端认证所需要的证书。然后使用credentialWithIdentity:certificates:persistence:来创建一个NSURLCredential对象。</li>
<li>服务端信任认证(NSURLAuthenticationMethodServerTrust)需要一个由认证请求的保护空间提供的信任。使用credentialForTrust:来创建一个NSURLCredential对象。</li>
</ol>


<p>在创建NSURLCredential对象后</p>

<ol>
<li>对于NSURLSession，使用提供的完成处理block将该对象传递给认证请求发送者</li>
<li>对于NSURLConnection和NSURLDownload，使用useCredential:forAuthenticationChallenge:方法将对象传递给认证请求发送者。</li>
</ol>


<h4>尝试在没有证书的情况下继续</h4>

<p>如果代理选择不提供证书，可以尝试继续操作：</p>

<ol>
<li>对于NSURLSession，传递下面的值给完成处理block:
 NSURLSessionAuthChallengePerformDefaultHandling:处理请求。尽管代理没有提供代理方法来处理认证请求
 NSURLSessionAuthChallengeRejectProtectionSpace:拒绝请求。依赖于服务端响应允许的认证类型，URL加载类可能多次调用这个代理方法。</li>
<li>对于NSURLConnection和NSURLDownload，在[challenge sender]中调用continueWithoutCredentialsForAuthenticationChallenge:。</li>
</ol>


<p>依赖于协议的实现，这种处理方法可能会导致连接失败而以送connectionDidFailWithError:消息，或者返回可选的不需要认证的URL内容。</p>

<h4>取消连接</h4>

<p>代理可以选择取消认证请求</p>

<ol>
<li>对于NSURLSession，传递NSURLSessionAuthChallengeCancelAuthenticationChallenge给完成处理block</li>
<li>对于NSURLConnection和NSURLDownload，在[challenge sender]中调用cancelAuthenticationChallenge:。代理接收connection:didCancelAuthenticationChallenge:消息，以提供用户反馈的机会。</li>
</ol>


<p>下面的代码演示了使用用户名和密码创建NSURLCredential对象来响应认证请求</p>

<pre><code>-(void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge
    {
    if ([challenge previousFailureCount] == 0)

    {
                NSURLCredential *newCredential;
        newCredential = [NSURLCredential credentialWithUser:[self preferencesName] password:[self preferencesPassword] persistence:NSURLCredentialPersistenceNone];
        [[challenge sender] useCredential:newCredential forAuthenticationChallenge:challenge];
    }

    else

    {           [[challenge sender] cancelAuthenticationChallenge:challenge];           // inform the user that the user name and password          // in the preferences are incorrect         [self showPreferencesCredentialsAreIncorrectPanel:self];        }

}
</code></pre>

<p>如果代理没有实现connection:didReceiveAuthenticationChallenge:，而请求需要认证，则有效的证书必须位于URL证书存储中或作为请求URL的一部分。如果证书无效或者认证失败，则底层实现会发送一个continueWithoutCredentialForAuthenticationChallenge:消息。</p>

<h2>执行自定义TLS链验证</h2>

<p>在NSURL系统的AIP中，TLS链验证由应用的认证代理方法来处理，但它不是提供证书给服务端以验证用户，而是在TLS握手的过程中校验服务端提供的证书，然后再告诉URL加载系统是否应该接受还是拒绝这些证书。</p>

<p>如果需要以非标准的方法(如接收一个指定的自标识的证书用于测试)来执行链验证，则应用必须如下处理：</p>

<ol>
<li>对于NSURLSession，实现URLSession:didReceiveChallenge:completionHandler:和URLSession:task:didReceiveChallenge:completionHandler:代理方法。如果实现了两者，由会话级别的方法负责处理认证。</li>
<li>对于NSURLConnection和NSURLDownload，实现connection:canAuthenticateAgainstProtectionSpace:和download:canAuthenticateAgainstProtectionSpace:方法，如果保护空间有一个NSURLAuthenticationMethodServerTrust类型的认证，则返回YES。然后，实现connection:didReceiveAuthenticationChallenge:或download:didReceiveAuthenticationChallenge:方法来处理认证。</li>
</ol>


<p>在认证处理代理方法中，我们需要确认认证保护空间是否有NSURLAuthenticationMethodServerTrust类型的认证，如果有，则从保护空间获取serverTrust信息。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/15/urljia-zai-xi-tong-zhi-san-:nsurlconnection/">URL加载系统之三：NSURLConnection</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-15T18:37:44+08:00" pubdate data-updated="true">Jul 15<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/07/15/urljia-zai-xi-tong-zhi-san-:nsurlconnection/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>NSURLConnection提供了简单的接口来创建和取消一个连接，并支持一个代理方法的集合来提供连接的响应，并对连接进行多方面的控制。这个类的方法可以分为5大类：URL加载、缓存管理、认证与证书、cookie存储、协议支持。</p>

<h2>创建一个连接</h2>

<p>NSURLConnection提供了三种方式来获取URL的内容：同步、异步使用完成处理器block、异步使用自定义的代理对象。</p>

<ol>
<li>使用同步请求时，一般是在后台线程中独占线程运行，我们可以调用sendSynchronousRequest:returningResponse:error: 方法来执行HTTP请求。当请求完成或返回错误时，该方法会返回。</li>
<li>如果我们不需要监听请求的状态，而只是在数据完成返回时执行一些操作，则可以调用sendAsynchronousRequest:queue:completionHandler:方法来执行一个异步操作，其中需要传递一个block来处理结果。</li>
<li>我们也可以创建一个代理对象来处理异步请求，此时我们需要实现以下方法：connection:didReceiveResponse:、connection:didReceiveData:、connection:didFailWithError:和connectionDidFinishLoading: 。这些方法在NSURLConnectionDelegate、NSURLConnectionDownloadDelegate和 NSURLConnectionDataDelegate协议中定义。</li>
</ol>


<p>代码清单1以代理对象异步请求为例，初始化了一个URL连接并实现代理方法来处理连接响应</p>

<pre><code>@interface Conn : NSObject
{
    NSURLConnection *theConnection;
    NSMutableData *receivedData;
}

@end

@implementation Conn

- (void)createConnection
{
    // 创建一个请求
    NSURLRequest *theRequest=[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.apple.com/"]
                                              cachePolicy:NSURLRequestUseProtocolCachePolicy
                                          timeoutInterval:60.0];
    
    // 创建NSMutableData来保存接收到的数据
    receivedData = [NSMutableData dataWithCapacity: 0];
    
    // 使用theRequest创建一个连接并开始加载数据
    // 调用initWithRequest:delegate后会立即开始传输
    // 请求可以在connectionDidFinishLoading:或connection:didFailWithError:消息被发送前通过调用cancel来取消
    theConnection = [[NSURLConnection alloc] initWithRequest:theRequest delegate:self];
    
    if (!theConnection) {
        // 释放receivedData对象
        receivedData = nil;
        // 通知用户连接失败
    }
}

// 当服务端提供了有效的数据来创建NSURLResponse对象时，代理会收到connection:didReceiveResponse:消息。
// 这个代理方法会检查NSURLResponse对象并确认数据的content-type，MIME类型，文件 名和其它元数据。
// 需要注意的是，对于单个连接，我们可能会接多次收到connection:didReceiveResponse:消息；这咱情况发生在
// 响应是多重MIME编码的情况下。每次代理接收到connection:didReceiveResponse:时，应该重设进度标识
// 并丢弃之前接收到的数据。
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
{
    [receivedData setLength:0];
}

// 代理会定期接收到connection:didReceiveData:消息，该消息用于接收服务端返回的数据实体。该方法负责存储数据。
// 我们也可以用这个方法提供进度信息，这种情况下，我们需要在connection:didReceiveResponse:方法中
// 调用响应对象的expectedContentLength方法来获取数据的总长度。
- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
{
    [receivedData appendData:data];
}

// 如果数据传输的过程中出现了错误，代理会接收到connection:didFailWithError:消息。其中error参数给出了错误信息。
// 在代理收到connection:didFailWithError:消息后，它不会再接收指定连接的代理消息。
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
{
    theConnection = nil;
    receivedData = nil;

    NSLog(@"Connection failed! Error - %@ %@", [error localizedDescription], [[error userInfo] objectForKey:NSURLErrorFailingURLStringErrorKey]);
}

// 如果成功获取服务端返回的所有数据，则代理会收到connectionDidFinishLoading:消息。
- (void)connectionDidFinishLoading:(NSURLConnection *)connection
{
    NSLog(@"Succeeded! Receive %lu bytes of data(unsigned long)",[receivedData length]);

    theConnection = nil;
    receivedData = nil;
}

@end
</code></pre>

<h2>发起一个POST请求</h2>

<p>我们可以像发起其它URL请求一样，发起一个HTTP或HTTPS POST请求。主要的区别在于我们必须先配置好NSMutableURLRequest对象，并将其作为参数传递给initWithRequest:delegate:方法。</p>

<p>另外，我们还需要构造请求的body数据。可以以下面三种方式来处理</p>

<ol>
<li>对于上传短小的内存数据，我们需要对已存在的数据块进行URL编码</li>
<li>如果是从磁盘中上传文件，则调用setHTTPBodyStream:方法来告诉NSMutableURLRequest从一个NSInputStream中读取并使用结果数据作为body的内容</li>
<li>对于大块的数据，调用CFStreamCreateBoundPair来创建流对象对，然后调用setHTTPBodyStream:方法来告诉NSMutableURLRequest使用这些流对象中的一个作为body内容的源。通过将数据写入其它流，可以一次发送一小块数据。</li>
</ol>


<p>如果要上传数据到一个兼容的服务器中，URL加载系统同样支持100（继续）状态码，这样允许一个上传操作在发生认证错误或其它失败时仍能继续。为了开启这个操作，可以设置请求对象的expect头为100-continue。</p>

<p>代码清单2展示了如何配置一个POST请求的NSMutableURLRequest对象</p>

<pre><code>- (void)setRequestForPost
{
    // 对于application/x-www-form-urlencoded类型的body数据，form域的参数由&amp;号分开，
    NSString *bodyData = @"name=Jane+Doe&amp;address=123+Main+St";
    NSMutableURLRequest *postRequest = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://www.apple.com"]];
    
    // 设置content-type为application/x-www-form-urlencoded
    [postRequest setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
    
    // 指定请求方法为POST
    [postRequest setHTTPMethod:@"POST"];
    [postRequest setHTTPBody:[NSData dataWithBytes:[bodyData UTF8String] length:strlen([bodyData UTF8String])]];
    
    // Initialize the NSURLConnection and proceed as described in
    // Retrieving the Contents of a URL
    
}
</code></pre>

<h2>使用Block来接收数据</h2>

<p>NSURLConnection类提供了类方法sendAsynchronousRequest:queue:completionHandler:，该方法可以以异常的方式向服务端发起请求，并在数据返回或发生错误/超时时调用block来处理。该方法需要一个请求对象，一个完成处理block，及block运行的队列。当请求完成或错误发生时，URL加载系统调用该block来处理结果数据或错误信息。</p>

<p>如果请求成功，则会传递一个NSData对象和一个NSURLResponse对象给block。如果失败，则传递一个NSError对象。</p>

<p>这个方法有两个限制</p>

<ol>
<li>对于需要认证的请求，只提供最小的支持。</li>
<li>没有办法来修改响应缓存和服务端重定向的默认行为。</li>
</ol>


<p>参考：
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System Programming Guide</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/11/urljia-zai-xi-tong-zhi-er-:nsurlsession/">URL加载系统之二：NSURLSession</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-11T22:48:27+08:00" pubdate data-updated="true">Jul 11<sup>th</sup>, 2014</time>
        
        
           | <a href="/blog/2014/07/11/urljia-zai-xi-tong-zhi-er-:nsurlsession/#comments">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>NSURLSession及相关的类提供通过HTTP协议下载数据的API。该类提供了大量代理方法来支持认证和后台下载(程序未运行或挂起时)功能。</p>

<p>为了使用NSURLSession，我们的应用会创建一系列的会话，每个会话负责协调一组相关数据的传输任务。在每个会话中，我们的应用添加一系列的任务，每个任务都表示一个对指定URL的请求。与大多数网络API一样，NSURLSession  API是异步的。如果我们使用系统提供的代理，我们必须提供一个请求完成处理block，以便在请求成功或失败时返回数据给我们的应用。如果我们提供自定义的代理对象，则任务对象调用这些代理方法，并回传从服务端获取的数据（如果是文件下载，则当传输完成时调用）。</p>

<p>NSURLSession提供了status和progress属性，并作为额外的信息传递给代理。同时它支持取消、恢复、挂起操作，并支持断点续传功能。</p>

<p>要掌握NSURLSession的使用，我们需要了解下URL会话的一些内容</p>

<h2>URL会话</h2>

<p>在一个会话中的任务的行为取决于三个方面：</p>

<ol>
<li>session的类型（由创建会话时的配置对象确定）</li>
<li>任务的类型</li>
<li>当任务创建时应用是否在前台</li>
</ol>


<p>NSURLSession支持以下三种会话类型：</p>

<ol>
<li>默认会话：行为与其它下载URL的Foundation方法类似。使用基于磁盘的缓存策略，并在用户keychain中存储证书。</li>
<li>短暂会话(Ephemeral sessions)：不存储任何数据在磁盘中；所有的缓存，证书存储等都保存在RAM中并与会话绑定。这样，当应用结束会话时，它们被自动释放。</li>
<li>后台会话(Background sessions)：类似于默认会话，除了有一个独立的进程来处理所有的数据传输。</li>
</ol>


<p>在一个会话中，NSURLSession支持三种任务类型</p>

<ol>
<li>数据任务：使用NSData对象来发送和接收数据。数据任务可以分片返回数据，也可以通过完成处理器一次性返回数据。由于数据任务不存储数据到文件，所以不支持后台会话.</li>
<li>下载任务：以文件的形式接收数据，当程序不运行时支持后台下载</li>
<li>上传任务：通常以文件的形式发送数据，支持后台上传。</li>
</ol>


<p>NSURLSession支持在程序挂起时在后台传输数据。后台传输只由使用后台会话配置对象创建的会话提供。使用后台会话时，由于实际传输是在一个独立的进程中传输，且重启应用进程相当损耗资源，只有少量特性可以使用，所以有以下限制：</p>

<ol>
<li>会话必须提供事件分发的代理。</li>
<li>只支持HTTP和HTTPS协议</li>
<li>只支持上传和下载任务</li>
<li>总是伴随着重定义操作</li>
<li>如果当应用在后台时初始化的后台传输，则配置对象的discretionary属性为true</li>
</ol>


<p>在iOS中，当我们的应用不再运行时，如果后台下载任务完成或者需要证书，则系统会在后台自动重启我们的应用，同时调用UIApplicationDelegate对象的application:handlerEventsForBackgroundURLSession:completionHandler:方法。这个调用会提供启动的应用的session的标识。我们的应用应该存储完成处理器，使用相同的标识来创建后台配置对象，然后使用配置对象来创建会话。新的会话会与运行的后台activity关联。当会话完成后台下载任务时，会给会话代理发送一个URLSessioinDidFinishEventsForBackgroundURLSession:消息。我们的代理对象然后调用存储的完成处理器。</p>

<p>如果在程序挂起时有任何任务完成，则会调用URLSession:downloadTask:didFinishDownloadingToURL:方法。同样的，如果任务需要证书，则NSURLSession对象会在适当的时候调用URLSession:task:didReceiveChallenge:completionHandler: 和URLSession:didReceiveChallenge:completionHandler:方法。</p>

<p>这里需要注意的是必须为每个标识创建一个会话，共享相同标识的多个会话的行为是未定义的。</p>

<p>会话和任务对象实现了NSCopying协议：</p>

<ol>
<li>当应用拷贝一个会话或任务对象时，会获取相同对象的指针</li>
<li>当应用拷贝一个配置对象时，会获取一个可单独修改的新的对象</li>
</ol>


<h2>创建并配置NSURLSession</h2>

<p>我们下面举个简单的实例来说明一个NSURLSession与服务端的数据交互。</p>

<h6>代码清单1：声明三种类型会话对象</h6>

<pre><code>@interface URLSession : NSObject &lt;NSURLSessionDelegate, NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;

@property (nonatomic, strong) NSURLSession *backgroundSession;
@property (nonatomic, strong) NSURLSession *defaultSession;
@property (nonatomic, strong) NSURLSession *ephemeralSession;
@property (nonatomic, strong) NSMutableDictionary *completionHandlerDictionary;

- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier;

- (void)callCompletionHandlerForSession:(NSString *)identifier;

@end
</code></pre>

<p>NSURLSession提供了大量的配置选项，包括：</p>

<ol>
<li>支持缓存、cookie，认证及协议的私有存储</li>
<li>认证</li>
<li>上传下载文件</li>
<li>每个主机的配置最大数</li>
<li>超时时间</li>
<li>支持的TLS最小最小版本</li>
<li>自定义代理字典</li>
<li>控制cookie策略</li>
<li>控制HTTP管道行为</li>
</ol>


<p>由于大部分设置都包含在一个独立的配置对象中，所以我们可以重用这些配置。当我们初始一个会话对象时，我们指定了如下内容</p>

<ol>
<li>一个配置对象，用于管理其中的会话和任务的行为</li>
<li>一个代理对象，用于在收到数据时处理输入数据，及会话和任务中的其它事件，如服务端认证、确定一个资源加载请求是否应该转换成下载等。这个对象是可选的。但如果我们需要执行后台传输，则必须提供自定义代理。</li>
</ol>


<p>在实例一个会话对象后，我们不能改变改变配置或代理。</p>

<h6>代码清单2演示了如何创建一个会话</h6>

<pre><code>NSURLSessionConfiguration *defaultConfigObject = [NSURLSessionConfiguration defaultSessionConfiguration];
        
// 配置会话的缓存
NSString *cachePath = @"/MyCacheDirectory";
        
NSArray *pathList = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
NSString *path = [pathList objectAtIndex:0];
        
NSString *bundleIdentifier = [[NSBundle mainBundle] bundleIdentifier];
        
NSString *fullCachePath = [[path stringByAppendingPathComponent:bundleIdentifier] stringByAppendingPathComponent:cachePath];
        
NSLog(@"Cache path: %@", fullCachePath);
        
NSURLCache *cache = [[NSURLCache alloc] initWithMemoryCapacity:16384 diskCapacity:268435456 diskPath:cachePath];
defaultConfigObject.URLCache = cache;
defaultConfigObject.requestCachePolicy = NSURLRequestUseProtocolCachePolicy;
        
self.defaultSession = [NSURLSession sessionWithConfiguration:defaultConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
</code></pre>

<p>除了后台配置对象外，我们可以重用会话的配置对象来创建新的会话，正如上面所讲的，拷贝一个配置对象会生成一个新的独立的配置对象。我们可以在任何时候安全的修改配置对象。当创建一个会话时，会话会对配置对象进行深拷贝，所以修改只会影响到新的会话。代理清单3演示了创建一个新的会话，这个会话使用重用的配置对象。</p>

<h6>代码清单3：重用会话对象</h6>

<pre><code>self.ephemeralSession = [NSURLSession sessionWithConfiguration:ephemeralConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
        
ephemeralConfigObject.allowsCellularAccess = YES;
        
// ...
NSURLSession *ephemeralSessionWifiOnly = [NSURLSession sessionWithConfiguration:ephemeralConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
</code></pre>

<p>使用NSURLSession获取数据基本就是两步：</p>

<ol>
<li>创建一个配置对象及基于这个对象的会话</li>
<li>定义一个请求完成处理器来处理获取到的数据。</li>
</ol>


<p>如果使用系统提供的代理，只需要代码清单4这几行代码即可搞定</p>

<h6>代码清单4：使用系统提供代理</h6>

<pre><code>NSURLSession *delegateFreeSession = [NSURLSession sessionWithConfiguration:defaultConfigObject delegate:self delegateQueue:[NSOperationQueue mainQueue]];
[delegateFreeSession dataTaskWithRequest:@"http://www.sina.com"
                               completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {    
                                   NSLog(@"Got response %@", response);
                               }];
</code></pre>

<p>只是系统提供的代理只提供有限的网络行为。如果应用需要更多的处理，如自定义认证或后台下载等，则需要使用自定义的代理。使用自定义代理来获取数据时，代理必须实现以下方法：</p>

<ol>
<li>URLSession:dataTask:didReceiveData: 从请求提供数据给我们的任务，一次一个数据块</li>
<li>URLSession:task:didCompleteWithError: 表示任务已经接受了所有的数据。</li>
</ol>


<p>如果我们在URLSession:dataTask:didReceiveData:方法返回后使用数据，则需要将数据存储在某个地方。</p>

<h6>代码清单5：演示了一个数据访问实例：</h6>

<pre><code>NSURL *url = [NSURL URLWithString:@"http://www.sina.com"];
NSURLSessionDataTask *dataTask = [self.defaultSession dataTaskWithURL:url];
[dataTask resume];
</code></pre>

<p>如果远程服务器返回的状态表示需要一个认证，且认证需要连接级别的处理时，NSURLSession将调用认证相关代理方法。这个具体我们后面文章将详细讨论。</p>

<h2>处理iOS后台Activity</h2>

<p>在iOS中使用NSURLSession时，当一个下载完成时，会自动启动我们的应用。应用的代理方法application:handleEventsForBackgroundURLSession:completionHandler: 负责创建一个合适的会话，存储请求完成处理器，并在会话调用会话代理的URLSessionDidFinishEventsForBackgroundURLSession: 方法时调用这个处理器。代码清单6与代码清单7演示了这个处理流程</p>

<h6>代码清单6：iOS后台下载的会话代理方法</h6>

<pre><code>- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session
{
    NSLog(@"background url session %@", session);
    
    if (session.configuration.identifier)
    {
        [self callCompletionHandlerForSession:session.configuration.identifier];
    }
}

- (void)callCompletionHandlerForSession:(NSString *)identifier
{
    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey:identifier];
    
    if (handler) {
        [self.completionHandlerDictionary removeObjectForKey:identifier];
        
        handler();
    }
}
</code></pre>

<h6>代码清单7：iOS后台下载的App 代理方法</h6>

<pre><code>- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler
{
    NSURLSessionConfiguration *backgroundConfigObject = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];
    
    URLSession *sessionDelegate = [[URLSession alloc] init];
    
    NSURLSession *backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfigObject
                                                                    delegate:sessionDelegate
                                                               delegateQueue:[NSOperationQueue mainQueue]];
    
    [sessionDelegate addCompletionHandler:completionHandler forSession:identifier];
}
</code></pre>

<p>参考：</p>

<ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html">URL Loading System Programming Guide</a></li>
</ol>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/11">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/9">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    
<section>
<h1>分类</h1>
<ul>
  <li><a href='/blog/categories/ios'>ios (58)</a></li>
  <li><a href='/blog/categories/network'>network (3)</a></li>
  <li><a href='/blog/categories/reactivecocoa'>reactivecocoa (3)</a></li>
  <li><a href='/blog/categories/swift'>swift (7)</a></li>
  <li><a href='/blog/categories/system'>system (1)</a></li>
  <li><a href='/blog/categories/网络'>网络 (8)</a></li>
</ul>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/03/01/fan-yi-pian-:ios-8-handoff-tutorial/">翻译篇：iOS 8 Handoff Tutorial</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/11/nscache/">NSCache</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/02/07/yuan-ma-pian-:sdwebimage/">源码篇：SDWebImage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/nsobjectzhi-er/">NSObject之二</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/31/nsobjectzhi-%5B%3F%5D/">NSObject之一</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/25/gong-ju-pian-:lldbdiao-shi-qi/">工具篇：LLDB调试器</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/yuan-ma-pian-:mantle/">源码篇：Mantle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/11/gong-ju-pian-:mantle/">工具篇：Mantle</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-san-:pdfwen-dang-de-chuang-jian-,-xian-shi-ji-zhuan-huan/">Quartz 2D编程指南之十三：PDF文档的创建、显示及转换</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/08/quartz-2dbian-cheng-zhi-nan-zhi-shi-er-:core-graphicsceng-hui-zhi/">Quartz 2D编程指南之十二：Core Graphics层绘制</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - 南峰子 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000523916'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1000523916%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
</p>

</footer>
  











</body>
</html>
